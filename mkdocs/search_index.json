{
    "docs": [
        {
            "location": "/",
            "text": "The MoMEMta project\n#\n\n\nMoMEMta\n is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for the most common final states (\n\\(\\text{t}\\bar{\\text{t}}\\)\n, WW, \u2026). If you are an expert user, be prepared to feel the freedom of configuring your MEM computation at all levels.\n\n\nMoMEMta is based on:\n\n\n\n\nC++, ROOT, Lua scripting language\n\n\nCuba (Monte-Carlo integration library)\n\n\nExternal PDFs (LHAPDF by default)\n\n\nExternal Matrix Element (provided by our MadGraph C++ exporter plugin)\n\n\n\n\nYou will probably want to start with our \ngetting started guide\n.\n\n\nOur team\n#\n\n\n\n\nS\u00e9bastien Brochet\n\n\nAlessia Saggio\n\n\nMiguel Vidal\n\n\nS\u00e9bastien Wertz",
            "title": "Main"
        },
        {
            "location": "/#the-momemta-project",
            "text": "MoMEMta  is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for the most common final states ( \\(\\text{t}\\bar{\\text{t}}\\) , WW, \u2026). If you are an expert user, be prepared to feel the freedom of configuring your MEM computation at all levels.  MoMEMta is based on:   C++, ROOT, Lua scripting language  Cuba (Monte-Carlo integration library)  External PDFs (LHAPDF by default)  External Matrix Element (provided by our MadGraph C++ exporter plugin)   You will probably want to start with our  getting started guide .",
            "title": "The MoMEMta project"
        },
        {
            "location": "/#our-team",
            "text": "S\u00e9bastien Brochet  Alessia Saggio  Miguel Vidal  S\u00e9bastien Wertz",
            "title": "Our team"
        },
        {
            "location": "/introduction/",
            "text": "Introduction\n#\n\n\nThe Matrix Element Method\n#\n\n\nThe Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event:\n\n\n\n\nP(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int  \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM}\n\n\n\n\nWhere:\n\n\n\n\n\n\n\\(\\mathcal{M}_{\\alpha}\\)\n is the matrix element (usually LO) under hypothesis \n\\(\\alpha\\)\n.\n\n\n\n\n\n\nThe transfer function \n\\(W(\\mathbf{x}|y)\\)\n is the probability density that \n\\(y\\)\n ends up as the measured event \n\\(\\mathbf{x}\\)\n in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as \n\\(\\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1\\)\n while the probability that \n\\(y\\)\n ends up as a selected event is included in the efficiency term \n\\(\\epsilon_{\\alpha}(y)\\)\n.\n\n\n\n\n\n\n\\(f\\)\n and \n\\(x_i\\)\n are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x; \n\\(\\text{d} \\Phi(y)\\)\n is the phase-space density term; \n\\(s\\)\n is the hadronic centre-of-mass energy.\n\n\n\n\n\n\nThe denominator \n\\(A_{\\alpha} \\sigma_{\\alpha}\\)\n, including the total cross-section of the process \n\\(\\alpha\\)\n and the overall acceptance \n\\(A_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle\\)\n ensures that \n\\(P\\)\n is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected.\n\n\n\n\n\n\nThis per-event likelihood has two main analysis use-cases:\n\n\n\n\n\n\nConstructing the sample likelihood \n\\(\\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha)\\)\n and measuring a parameter using the maximum likelihood method\n\n\n\n\n\n\nConstructing a Neyman-Pearson discriminant \n\\(P(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta)\\)\n to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals\n\n\n\n\n\n\nHowever, computing an integral like (\n\\(\\ref{MEM}\\)\n) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms \nand\n smart phase-space parametrisations.\n\n\nMoMEMta\n#\n\n\nMoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows.\n\n\nThe modularity of MoMEMta consists of configuring the integrand of (\n\\(\\ref{MEM}\\)\n) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using the Vegas algorithm as implemented in the Cuba library.",
            "title": "What is MoMEMta?"
        },
        {
            "location": "/introduction/#introduction",
            "text": "",
            "title": "Introduction"
        },
        {
            "location": "/introduction/#the-matrix-element-method",
            "text": "The Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event:   P(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int  \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM}   Where:    \\(\\mathcal{M}_{\\alpha}\\)  is the matrix element (usually LO) under hypothesis  \\(\\alpha\\) .    The transfer function  \\(W(\\mathbf{x}|y)\\)  is the probability density that  \\(y\\)  ends up as the measured event  \\(\\mathbf{x}\\)  in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as  \\(\\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1\\)  while the probability that  \\(y\\)  ends up as a selected event is included in the efficiency term  \\(\\epsilon_{\\alpha}(y)\\) .    \\(f\\)  and  \\(x_i\\)  are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x;  \\(\\text{d} \\Phi(y)\\)  is the phase-space density term;  \\(s\\)  is the hadronic centre-of-mass energy.    The denominator  \\(A_{\\alpha} \\sigma_{\\alpha}\\) , including the total cross-section of the process  \\(\\alpha\\)  and the overall acceptance  \\(A_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle\\)  ensures that  \\(P\\)  is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected.    This per-event likelihood has two main analysis use-cases:    Constructing the sample likelihood  \\(\\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha)\\)  and measuring a parameter using the maximum likelihood method    Constructing a Neyman-Pearson discriminant  \\(P(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta)\\)  to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals    However, computing an integral like ( \\(\\ref{MEM}\\) ) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms  and  smart phase-space parametrisations.",
            "title": "The Matrix Element Method"
        },
        {
            "location": "/introduction/#momemta",
            "text": "MoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows.  The modularity of MoMEMta consists of configuring the integrand of ( \\(\\ref{MEM}\\) ) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using the Vegas algorithm as implemented in the Cuba library.",
            "title": "MoMEMta"
        },
        {
            "location": "/getting-started/",
            "text": "Getting started\n#\n\n\nInstallation\n#\n\n\nPrerequisites\n#\n\n\nMoMEMta depends on the following libraries and tools:\n\n\n\n\nLHAPDF (>=6)\n\n\nCMake (>=3.2)\n\n\nBoost (>=1.54)\n\n\nROOT (>=5.34.09)\n\n\nA C++11-capable compiler\n\n\n\n\nNote\n: MoMEMta has only been tested on GNU/Linux.\n\n\nCompilation\n#\n\n\nRetrieve the code on \nour github repository\n. Unpack the archive and / or go to the \nMoMEMta\n directory. Next, execute the following:\n\n\nmkdir build\ncd build\ncmake ..\nmake -j 4\n\n\n\n\n\nYou can now use the library \nlibmomemta.so\n with your own code.\n\n\nFinally, you may then make MoMEMta (public headers and library) available system-wide using:\n\n\nmake install\n\n\n\n\n\nBuild options\n#\n\n\nThe following options are available when configuring the build (when running \ncmake ..\n):\n\n\n\n\n-DCMAKE_INSTALL_PREFIX=(path)\n: Install MoMEMta in a specific location when running \nmake install\n (useful if you don't have admin rights)\n\n\n-DPROFILING=ON\n: Generate debugging symbols and profiling information (requires \ngperftools\n)\n\n\n-DBOOST_ROOT=(path)\n: Use specific Boost library installation\n\n\n-DTESTS=ON\n: Also compile the test executables\n\n\n-DEXAMPLES=OFF\n: Do not compile the example executables\n\n\n\n\nUsage: Lua & MoMEMta\n#\n\n\nIn MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta!\n\n\nComputing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors:\n\n\n#include\n \n<momemta/ConfigurationReader.h>\n\n\n#include\n \n<momemta/Logging.h>\n\n\n#include\n \n<momemta/MoMEMta.h>\n\n\n#include\n \n<momemta/Utils.h>\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n**\n \nargv\n)\n \n{\n\n\n    \nConfigurationReader\n \nconfiguration\n(\n\"tt_fullyleptonic.lua\"\n);\n\n    \nMoMEMta\n \nweight\n(\nconfiguration\n.\nfreeze\n());\n\n\n    \nLorentzVector\n \np3\n(\n16.17\n,\n \n-\n13.79\n,\n \n-\n3.43\n,\n \n21.53\n);\n\n    \nLorentzVector\n \np4\n(\n-\n55.79\n,\n \n-\n111.59\n,\n \n-\n122.14\n,\n \n174.66\n);\n\n    \nLorentzVector\n \np5\n(\n-\n18.90\n,\n \n10.09\n,\n \n-\n0.60\n,\n \n21.43\n);\n\n    \nLorentzVector\n \np6\n(\n71.39\n,\n \n96.01\n,\n \n-\n77.25\n,\n \n142.50\n);\n\n\n    \nstd\n::\nvector\n<\nstd\n::\npair\n<\ndouble\n,\n \ndouble\n>>\n \nweights\n \n=\n \nweight\n.\ncomputeWeights\n({\np3\n,\n \np4\n,\n \np5\n,\n \np6\n});\n\n\n    \nstd\n::\ncout\n \n<<\n \n\"Result: \"\n \n<<\n \nweights\n.\nback\n().\nfirst\n \n<<\n \n\" +- \"\n \n<<\n \nweights\n.\nback\n().\nsecond\n;\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nExamples\n#\n\n\nWe ship a few example configuration files, along with short scripts computing a single weight: find them in \nMoMEMta/examples\n. To run them, simply call them from the \nbuild\n directory:\n\n\n./tt_fullyleptonic.exe\n./tt_fullyleptonic_NWA.exe\n./WW_fullyleptonic.exe\n\n\n\n\n\nA set of more comprehensive examples on how to run MoMEMta can be found in our \nTutorials repository\n. Each of these examples includes a matrix element generated by our exporter, a ROOT file containing a few events, a Lua configuration file and a small source code showing how to compute weights for the events in the sample.\n\n\nMatrix elements\n#\n\n\nMoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our \nMatrix Element Exporter\n, a plugin for \nMadGraph5_aMC@NLO\n (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s README file. \n\n\nSupport for other matrix element generators is planned for futures releases.",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#installation",
            "text": "Prerequisites #  MoMEMta depends on the following libraries and tools:   LHAPDF (>=6)  CMake (>=3.2)  Boost (>=1.54)  ROOT (>=5.34.09)  A C++11-capable compiler   Note : MoMEMta has only been tested on GNU/Linux.  Compilation #  Retrieve the code on  our github repository . Unpack the archive and / or go to the  MoMEMta  directory. Next, execute the following:  mkdir build\ncd build\ncmake ..\nmake -j 4  You can now use the library  libmomemta.so  with your own code.  Finally, you may then make MoMEMta (public headers and library) available system-wide using:  make install  Build options #  The following options are available when configuring the build (when running  cmake .. ):   -DCMAKE_INSTALL_PREFIX=(path) : Install MoMEMta in a specific location when running  make install  (useful if you don't have admin rights)  -DPROFILING=ON : Generate debugging symbols and profiling information (requires  gperftools )  -DBOOST_ROOT=(path) : Use specific Boost library installation  -DTESTS=ON : Also compile the test executables  -DEXAMPLES=OFF : Do not compile the example executables",
            "title": "Installation"
        },
        {
            "location": "/getting-started/#usage-lua-momemta",
            "text": "In MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta!  Computing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors:  #include   <momemta/ConfigurationReader.h>  #include   <momemta/Logging.h>  #include   <momemta/MoMEMta.h>  #include   <momemta/Utils.h>  int   main ( int   argc ,   char **   argv )   { \n\n     ConfigurationReader   configuration ( \"tt_fullyleptonic.lua\" ); \n     MoMEMta   weight ( configuration . freeze ()); \n\n     LorentzVector   p3 ( 16.17 ,   - 13.79 ,   - 3.43 ,   21.53 ); \n     LorentzVector   p4 ( - 55.79 ,   - 111.59 ,   - 122.14 ,   174.66 ); \n     LorentzVector   p5 ( - 18.90 ,   10.09 ,   - 0.60 ,   21.43 ); \n     LorentzVector   p6 ( 71.39 ,   96.01 ,   - 77.25 ,   142.50 ); \n\n     std :: vector < std :: pair < double ,   double >>   weights   =   weight . computeWeights ({ p3 ,   p4 ,   p5 ,   p6 }); \n\n     std :: cout   <<   \"Result: \"   <<   weights . back (). first   <<   \" +- \"   <<   weights . back (). second ; \n\n     return   0 ;  }",
            "title": "Usage: Lua & MoMEMta"
        },
        {
            "location": "/getting-started/#examples",
            "text": "We ship a few example configuration files, along with short scripts computing a single weight: find them in  MoMEMta/examples . To run them, simply call them from the  build  directory:  ./tt_fullyleptonic.exe\n./tt_fullyleptonic_NWA.exe\n./WW_fullyleptonic.exe  A set of more comprehensive examples on how to run MoMEMta can be found in our  Tutorials repository . Each of these examples includes a matrix element generated by our exporter, a ROOT file containing a few events, a Lua configuration file and a small source code showing how to compute weights for the events in the sample.",
            "title": "Examples"
        },
        {
            "location": "/getting-started/#matrix-elements",
            "text": "MoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our  Matrix Element Exporter , a plugin for  MadGraph5_aMC@NLO  (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s README file.   Support for other matrix element generators is planned for futures releases.",
            "title": "Matrix elements"
        },
        {
            "location": "/in-depth/calling-momemta/",
            "text": "In MoMEMta, the integration is defined by linking modules together in a Lua script. MoMEMta is shipped with a set of modules covering the most common needs and whose parameters, inputs and outputs are documented \nhere\n. For more information on how to write the configuration file, see \nhere\n.\n\n\n\n\nA module is just a C++ class deriving from the \nModule\n virtual class. How to write a new module and make it available for the calculation is described (here).\n\n\n\n\nOnce the configuration file is defined, it can be loaded by MoMEMta\u2019s configuration reader:\n\n\nConfigurationReader\n \nmy_reader\n(\n\"relative_path_to_lua_file.lua\"\n);\n\n\n\n\n\n\nAt this point, the user might wish to modify some parameters defined in the file from the code itself:\n\n\nconfiguration\n.\ngetGlobalParameters\n().\nset\n(\n\"top_mass\"\n,\n \n173.\n);\n\n\n\n\n\n\nThen, MoMEMta can be instantiated using a \"frozen\" configuration set:\n\n\nParameterSet\n \nmy_config\n \n=\n \nmy_reader\n.\nfreeze\n();\n\n\nMoMEMta\n \nweight\n(\nmy_config\n);\n\n\n\n\n\n\n\n\nMoMEMta is instantiated using a \nParameterSet\n, describing a fixed configuration: parameters cannot be modified at this stage. Parameters can be changed in the ConfigurationReader, and a new \nMoMEMta\n instance must then be constructed by calling \nConfigurationReader::freeze()\n again.\n\n\n\n\nThe weight can finally be computed by calling the computeWeights() method of the MoMEMta object, passing the observed particles as a set of LorentzVectors:\n\n\nLorentzVector\n \np1\n,\n \np2\n,\n \np3\n,\n \np4\n,\n \nmet\n;\n\n\nstd\n::\nvector\n<\nstd\n::\npair\n<\ndouble\n,\n \ndouble\n>>\n \nweights\n \n=\n \nweight\n.\ncomputeWeights\n({\np1\n,\n \np2\n,\n \np3\n,\n \np4\n},\n \nmet\n);\n\n\n\n\n\n\n\n\nThe MET is an optional parameter\n\n\nThe LorentzVectors are expected to be expressed in the \nPxPyPzE<double>\n basis\n\n\n\n\nThe function starts the Monte-Carlo integration: the integrand function is called a large number of times, each time passing as input a phase-space point vector (where the length of the vector is the dimensionality of the integrated phase-space) with elements lying between 0 and 1, and returning as output the integrated function evaluated on this point.\n\n\ncomputeWeights()\n returns a vector of pairs (weight, uncertainty) (at the moment, this vector only has one entry) which can then be stored by the user.\n\n\n\n\nThe phase-space points are associated with a weight, given that they are not distributed uniformly in the phase-space, but according to the importance function defined by Vegas. In most use cases this weight is not needed by the user since Cuba automatically takes it into account when computing the integral, however it can still be retrieved through the \ncuba::ps_weight\n input tag (see \nhere\n).",
            "title": "Calling MoMEMta"
        },
        {
            "location": "/in-depth/configuration-file/",
            "text": "The configuration file\n#\n\n\nConfiguring modules\n#\n\n\nDeclaring a module named \nkarl\n of type \nGaussian\n in Lua is simple:\n\n\nGaussian.karl = {}\n\n\n\n\n\nEach module can be configured by setting its parameters and its inputs:\n\n\nGaussian\n.\nkarl\n \n=\n \n{}\n\n\nGaussian\n.\nfriedrich\n \n=\n \n{\n\n    \n-- Some fixed parameters\n\n    \nage\n \n=\n \n25\n,\n\n    \nsize\n \n=\n \n1.75\n,\n\n    \nplace\n \n=\n \n\"\nGottingen\"\n,\n\n    \ndead\n \n=\n \ntrue\n,\n\n    \n-- Define inputs using other modules\u2019 outputs\n\n    \ninput\n \n=\n \n\"\nkarl::output\"\n\n\n}\n\n\n\n\n\n\nA \nparameter\n can be an integer (eg.: \n2\n), a floating point number, (eg.: \n172.5\n, \n13000.\n - note the decimal point \nmust\n be present), a boolean (\ntrue\n or \nfalse\n) or a string (eg.: \nhello\n). Parameters might have default values and be optional, or be mandatory.\n\n\nAn \ninput\n is set through a so-called \"\ninput tag\n\" of the form \nother_module::its_output[/i]\n, where \nother_module\n is the name of another module responsible for producing the quantity \nits_output\n, and \n/i\n has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input. \n\n\nSome modules expect \nvectors\n of input tags, where the order of the entries may or nor matter. Vectors in Lua are easily declared:\n\n\n-- Take first and third entry of vector output `output` of module `that_module`\n\n\ninputs\n \n=\n \n{\n \n\"\nthat_module::output/1\"\n,\n \n\"\nthat_module::output/3\"\n \n}\n\n\n\n\n\n\nAccessing entries of previously defined vectors is also possible:\n\n\ntemp_vector\n \n=\n \n{\n \n\"\nfirst\"\n,\n \n\"\nsecond\"\n,\n \n\"\nthird\"\n \n}\n\n\n-- Use only { \"first\", \"third\" }:\n\n\nmy_inputs\n \n=\n \n{\n \ntemp_vector\n[\n1\n],\n \ntemp_vector\n[\n3\n]\n \n}\n\n\n\n\n\n\nNB\n: The indexing of Lua vectors or input tags starts at \n1, not 0\n.\n\n\nWhen declared, a module tells MoMEMta how many dimensions it adds to the integration (for instance, adding a transfer function on the energy of a jet means integrating over the energy of the corresponding parton). If a module adds a dimension, it also means it requires a component of the phase-space point to be specified as input (see below). MoMEMta keeps track of the total number of dimensions needed for the integration. \n\n\nThe order in which the modules are declared in the script does not matter: MoMEMta automatically executes the module in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed.\n\n\nDefault inputs, outputs and parameters \n#\n\n\nSome inputs and outputs are not defined by any module \nper se\n but are used by MoMEMta to pass and retrieve important quantities:\n\n\nInputs:\n\n\n\n\n\n\ninput::particles\n: Vector of LorentzVectors passed as argument to \ncomputeWeights()\n\n\n\n\n\n\ninput::met\n: LorentzVector of the observed MET (optional argument to \ncomputeWeights()\n)\n\n\n\n\n\n\ncuba::ps_points\n: Vector of doubles between 0 and 1. Phase-space point, ie. set of random numbers launched by Cuba to perform the integration. The length of the vector is the total number of integration dimensions declared by the modules. Instead of manually specifying the \ncuba::ps_points/i\n input tags, it is possible to use to \ngetpspoint()\n function (which automatically increases \u201ci\u201d each time it is called).\n\n\n\n\n\n\ncuba::ps_weight\n: (double) Weight associated with the phase-space point\n\n\n\n\n\n\nOutputs:\n\n\n\n\nintegrands\n: Vector of doubles. This is the value taken to be the integrand, returned to Cuba to compute the integral. Exactly \none\n declared module \nmust\n produce this quantity.\n\n\n\n\nParameters:\n\n\n\n\n\n\ncuba\n\n\n\n\n\n\nparameters",
            "title": "Configuration file"
        },
        {
            "location": "/in-depth/configuration-file/#the-configuration-file",
            "text": "",
            "title": "The configuration file"
        },
        {
            "location": "/in-depth/configuration-file/#configuring-modules",
            "text": "Declaring a module named  karl  of type  Gaussian  in Lua is simple:  Gaussian.karl = {}  Each module can be configured by setting its parameters and its inputs:  Gaussian . karl   =   {}  Gaussian . friedrich   =   { \n     -- Some fixed parameters \n     age   =   25 , \n     size   =   1.75 , \n     place   =   \" Gottingen\" , \n     dead   =   true , \n     -- Define inputs using other modules\u2019 outputs \n     input   =   \" karl::output\"  }   A  parameter  can be an integer (eg.:  2 ), a floating point number, (eg.:  172.5 ,  13000.  - note the decimal point  must  be present), a boolean ( true  or  false ) or a string (eg.:  hello ). Parameters might have default values and be optional, or be mandatory.  An  input  is set through a so-called \" input tag \" of the form  other_module::its_output[/i] , where  other_module  is the name of another module responsible for producing the quantity  its_output , and  /i  has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input.   Some modules expect  vectors  of input tags, where the order of the entries may or nor matter. Vectors in Lua are easily declared:  -- Take first and third entry of vector output `output` of module `that_module`  inputs   =   {   \" that_module::output/1\" ,   \" that_module::output/3\"   }   Accessing entries of previously defined vectors is also possible:  temp_vector   =   {   \" first\" ,   \" second\" ,   \" third\"   }  -- Use only { \"first\", \"third\" }:  my_inputs   =   {   temp_vector [ 1 ],   temp_vector [ 3 ]   }   NB : The indexing of Lua vectors or input tags starts at  1, not 0 .  When declared, a module tells MoMEMta how many dimensions it adds to the integration (for instance, adding a transfer function on the energy of a jet means integrating over the energy of the corresponding parton). If a module adds a dimension, it also means it requires a component of the phase-space point to be specified as input (see below). MoMEMta keeps track of the total number of dimensions needed for the integration.   The order in which the modules are declared in the script does not matter: MoMEMta automatically executes the module in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed.",
            "title": "Configuring modules"
        },
        {
            "location": "/in-depth/configuration-file/#default-inputs-outputs-and-parameters",
            "text": "Some inputs and outputs are not defined by any module  per se  but are used by MoMEMta to pass and retrieve important quantities:  Inputs:    input::particles : Vector of LorentzVectors passed as argument to  computeWeights()    input::met : LorentzVector of the observed MET (optional argument to  computeWeights() )    cuba::ps_points : Vector of doubles between 0 and 1. Phase-space point, ie. set of random numbers launched by Cuba to perform the integration. The length of the vector is the total number of integration dimensions declared by the modules. Instead of manually specifying the  cuba::ps_points/i  input tags, it is possible to use to  getpspoint()  function (which automatically increases \u201ci\u201d each time it is called).    cuba::ps_weight : (double) Weight associated with the phase-space point    Outputs:   integrands : Vector of doubles. This is the value taken to be the integrand, returned to Cuba to compute the integral. Exactly  one  declared module  must  produce this quantity.   Parameters:    cuba    parameters",
            "title": "Default inputs, outputs and parameters "
        }
    ]
}