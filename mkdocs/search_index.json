{
    "docs": [
        {
            "location": "/", 
            "text": "The MoMEMta project\n\n\n\n\nMoMEMta\n is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for some common final states (\n\\text{t}\\bar{\\text{t}}\n, WW, \u2026). If you are an expert user, be prepared to feel the freedom of configuring your MEM computation at all levels!\n\n\nMoMEMta is based on:\n\n\n\n\nC++, \nROOT\n, \nLua\n scripting language\n\n\nCuba\n (Monte-Carlo integration library)\n\n\nExternal PDFs (\nLHAPDF\n by default)\n\n\nExternal Matrix Elements (currently provided by our MadGraph C++ \nexporter plugin\n)\n\n\n\n\nYou will probably want to start with our \ngetting started guide\n, or check out our set of \nworking examples\n.\n\n\nOur team\n\n\n\n\nS\u00e9bastien Brochet\n\n\nBrieuc Fran\u00e7ois\n\n\nAlessia Saggio\n\n\nMiguel Vidal\n\n\nS\u00e9bastien Wertz\n\n\n\n\nSpecial thanks to Matthias Komm who designed our logo!\n\n\nAcknowledgements\n\n\nThis work would not have been possible without the help of the MadWeight team and funding of:\n\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n\n\n\n\nMoMEMta is part of a project that has received funding from the European Horizon 2020 research and innovation programme under grant agreement N\u00b0675440.", 
            "title": "The MoMEMta project"
        }, 
        {
            "location": "/#the-momemta-project", 
            "text": "MoMEMta  is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for some common final states ( \\text{t}\\bar{\\text{t}} , WW, \u2026). If you are an expert user, be prepared to feel the freedom of configuring your MEM computation at all levels!  MoMEMta is based on:   C++,  ROOT ,  Lua  scripting language  Cuba  (Monte-Carlo integration library)  External PDFs ( LHAPDF  by default)  External Matrix Elements (currently provided by our MadGraph C++  exporter plugin )   You will probably want to start with our  getting started guide , or check out our set of  working examples .", 
            "title": "The MoMEMta project"
        }, 
        {
            "location": "/#our-team", 
            "text": "S\u00e9bastien Brochet  Brieuc Fran\u00e7ois  Alessia Saggio  Miguel Vidal  S\u00e9bastien Wertz   Special thanks to Matthias Komm who designed our logo!", 
            "title": "Our team"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "This work would not have been possible without the help of the MadWeight team and funding of:  \n     \n     \n     \n     \n       MoMEMta is part of a project that has received funding from the European Horizon 2020 research and innovation programme under grant agreement N\u00b0675440.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/introduction/", 
            "text": "Introduction\n\n\nThe Matrix Element Method\n\n\nThe Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event:\n\n\n\n\nP(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int  \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM}\n\n\n\n\nWhere:\n\n\n\n\n\n\n\n\n\\mathcal{M}_{\\alpha}\n is the matrix element (usually LO) under hypothesis \n\\alpha\n.\n\n\n\n\n\n\nThe transfer function \nW(\\mathbf{x}|y)\n is the probability density that \ny\n ends up as the measured event \n\\mathbf{x}\n in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as \n\\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1\n while the probability that \ny\n ends up as a selected event is included in the efficiency term \n\\epsilon_{\\alpha}(y)\n.\n\n\n\n\n\n\n\n\nf\n and \nx_i\n are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x; \n\\text{d} \\Phi(y)\n is the phase-space density term; \ns\n is the hadronic centre-of-mass energy.\n\n\n\n\n\n\nThe denominator \nA_{\\alpha} \\sigma_{\\alpha}\n, including the total cross-section of the process \n\\alpha\n and the overall acceptance \nA_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle\n ensures that \nP\n is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected.\n\n\n\n\n\n\nThis per-event likelihood has two main analysis use-cases:\n\n\n\n\n\n\nConstructing the sample likelihood \n\\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha)\n and measuring a parameter using the maximum likelihood method\n\n\n\n\n\n\nConstructing a Neyman-Pearson discriminant \nP(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta)\n to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals\n\n\n\n\n\n\nHowever, computing an integral like (\n\\ref{MEM}\n) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms \nand\n smart phase-space parametrisations.\n\n\nMoMEMta\n\n\nMoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows.\n\n\nThe modularity of MoMEMta consists in configuring the integrand of (\n\\ref{MEM}\n) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using Monte-Carlo algorithms (such as Vegas) as implemented in the Cuba library. MoMEMta ships modules convering most needs, but it is possible for the user to write additional modules to perform specific tasks.\n\n\nIt should be noted that MoMEMta provides dedicated phase-space parametrisations especially suited for the computation of MEM integrals, greatly improving the speed of the calculations compared to a naive approach. The philosophy of these parametrisations is mostly based on results described in \n1\n, with a few additions. \n\n\n\n\n\n\n\n\n\n\nPierre Artoisenet, Vincent Lemaitre, Fabio Maltoni and Olivier Mattelaer, \n\u201cAutomation of the matrix element reweighting method\u201d\n, JHEP \n12\n (2010) \n068\n, p. 17", 
            "title": "What is MoMEMta?"
        }, 
        {
            "location": "/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/introduction/#the-matrix-element-method", 
            "text": "The Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event:   P(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int  \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM}   Where:     \\mathcal{M}_{\\alpha}  is the matrix element (usually LO) under hypothesis  \\alpha .    The transfer function  W(\\mathbf{x}|y)  is the probability density that  y  ends up as the measured event  \\mathbf{x}  in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as  \\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1  while the probability that  y  ends up as a selected event is included in the efficiency term  \\epsilon_{\\alpha}(y) .     f  and  x_i  are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x;  \\text{d} \\Phi(y)  is the phase-space density term;  s  is the hadronic centre-of-mass energy.    The denominator  A_{\\alpha} \\sigma_{\\alpha} , including the total cross-section of the process  \\alpha  and the overall acceptance  A_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle  ensures that  P  is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected.    This per-event likelihood has two main analysis use-cases:    Constructing the sample likelihood  \\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha)  and measuring a parameter using the maximum likelihood method    Constructing a Neyman-Pearson discriminant  P(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta)  to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals    However, computing an integral like ( \\ref{MEM} ) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms  and  smart phase-space parametrisations.", 
            "title": "The Matrix Element Method"
        }, 
        {
            "location": "/introduction/#momemta", 
            "text": "MoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows.  The modularity of MoMEMta consists in configuring the integrand of ( \\ref{MEM} ) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using Monte-Carlo algorithms (such as Vegas) as implemented in the Cuba library. MoMEMta ships modules convering most needs, but it is possible for the user to write additional modules to perform specific tasks.  It should be noted that MoMEMta provides dedicated phase-space parametrisations especially suited for the computation of MEM integrals, greatly improving the speed of the calculations compared to a naive approach. The philosophy of these parametrisations is mostly based on results described in  1 , with a few additions.       Pierre Artoisenet, Vincent Lemaitre, Fabio Maltoni and Olivier Mattelaer,  \u201cAutomation of the matrix element reweighting method\u201d , JHEP  12  (2010)  068 , p. 17", 
            "title": "MoMEMta"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nInstallation\n\n\nPrerequisites\n\n\nMoMEMta depends on the following libraries and tools:\n\n\n\n\nLHAPDF (\n=6)\n\n\nCMake (\n=3.2)\n\n\nBoost (\n=1.54)\n\n\nROOT (\n=5.34.09)\n\n\nA C++11-capable compiler\n\n\n\n\n\n\nNote\n\n\nMoMEMta has only been tested on GNU/Linux.\n\n\n\n\nCompilation\n\n\nRetrieve the code on \nour github repository\n. Unpack the archive and / or go to the \nMoMEMta\n directory. Next, execute the following (unless one of the build options described below apply to your case):\n\n\nmkdir build\n\ncd\n build\ncmake ..\nmake -j \n4\n\n\n\n\n\n\nFinally, make MoMEMta (public headers and library) available using:\n\n\nmake install\n\n\n\n\n\nYou can now use MoMEMta  with your own code.\n\n\nBuild options\n\n\nThe following options are available when configuring the build (when running \ncmake ..\n):\n\n\n\n\n-DCMAKE_INSTALL_PREFIX=(path)\n: Install MoMEMta in a specific location when running \nmake install\n (useful if you don't have admin rights)\n\n\n-DPROFILING=ON\n: Generate debugging symbols and profiling information (requires \ngperftools\n)\n\n\n-DBOOST_ROOT=(path)\n: Use specific Boost version (path to its install directory)\n\n\n-DTESTS=ON\n: Also compile the test executables\n\n\n-DEXAMPLES=OFF\n: Do not compile the example executables\n\n\n-DPYTHON_BINDINGS=ON|OFF\n (\nOFF\n by default). Builds python bindings for MoMEMta. Requires python and boost::python.\n\n\n-DDEBUG_TIMING=ON|OFF\n (\nOFF\n by default). If \nON\n, a summary of how long each module ran is printed at the end of the integration. Can be useful to see which module to optimize.\n\n\n\n\nUsage: Lua \n MoMEMta\n\n\nIn MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta!\n\n\nComputing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors:\n\n\n#include\n \nmomemta/ConfigurationReader.h\n\n\n#include\n \nmomemta/MoMEMta.h\n\n\n#include\n \nmomemta/Types.h\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n**\n \nargv\n)\n \n{\n\n\n    \nConfigurationReader\n \nconfiguration\n(\ntt_fullyleptonic.lua\n);\n\n    \nMoMEMta\n \nweight\n(\nconfiguration\n.\nfreeze\n());\n\n\n    \nmomemta\n::\nParticle\n \nelectron\n \n{\n \nelectron\n,\n \nLorentzVector\n(\n16.17\n,\n \n-\n13.79\n,\n \n-\n3.43\n,\n \n21.53\n),\n \n-\n11\n \n};\n\n    \nmomemta\n::\nParticle\n \nbjet1\n \n{\n \nbjet1\n,\n \nLorentzVector\n(\n-\n55.79\n,\n \n-\n111.59\n,\n \n-\n122.14\n,\n \n174.66\n),\n \n5\n \n};\n\n    \nmomemta\n::\nParticle\n \nbjet2\n \n{\n \nbjet2\n,\n \nLorentzVector\n(\n-\n18.90\n,\n \n10.09\n,\n \n-\n0.60\n,\n \n21.43\n),\n \n-\n5\n \n};\n\n    \nmomemta\n::\nParticle\n \nmuon\n \n{\n \nmuon\n,\n \nLorentzVector\n(\n71.39\n,\n \n96.01\n,\n \n-\n77.25\n,\n \n142.50\n),\n \n13\n \n};\n\n\n    \nstd\n::\nvector\nstd\n::\npair\ndouble\n,\n \ndouble\n \nweights\n \n=\n \nweight\n.\ncomputeWeights\n(\n \n{\n \nelectron\n,\n \nmuon\n,\n \nbjet1\n,\n \nbjet2\n \n}\n \n);\n\n\n    \nstd\n::\ncout\n \n \nResult: \n \n \nweights\n.\nat\n(\n0\n).\nfirst\n \n \n +- \n \n \nweights\n.\nat\n(\n0\n).\nsecond\n;\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nExamples\n\n\nWe ship a few example configuration files, along with short scripts computing a single weight: find them in \nMoMEMta/examples\n. To run them, simply call them from the \nbuild\n directory:\n\n\n./tt_fullyleptonic.exe\n./tt_fullyleptonic_NWA.exe\n./WW_fullyleptonic.exe\n\n\n\n\n\nA set of more comprehensive examples on how to run MoMEMta can be found in our \nTutorials repository\n. Each of these examples includes a matrix element generated by our \nexporter\n (see below), a ROOT file containing a few events, a documented Lua configuration file and a small source code showing how to compute weights for the events in the sample.\n\n\nMatrix elements\n\n\nMoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our \nMatrix Element Exporter\n, a plugin for \nMadGraph5_aMC@NLO\n (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s \nREADME file\n. \n\n\nSupport for other matrix element generators is planned for futures releases, however nothing prevents plugging in any code returning the matrix element provided it is wrapped properly for MoMEMta.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#prerequisites", 
            "text": "MoMEMta depends on the following libraries and tools:   LHAPDF ( =6)  CMake ( =3.2)  Boost ( =1.54)  ROOT ( =5.34.09)  A C++11-capable compiler    Note  MoMEMta has only been tested on GNU/Linux.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#compilation", 
            "text": "Retrieve the code on  our github repository . Unpack the archive and / or go to the  MoMEMta  directory. Next, execute the following (unless one of the build options described below apply to your case):  mkdir build cd  build\ncmake ..\nmake -j  4   Finally, make MoMEMta (public headers and library) available using:  make install  You can now use MoMEMta  with your own code.", 
            "title": "Compilation"
        }, 
        {
            "location": "/getting-started/#build-options", 
            "text": "The following options are available when configuring the build (when running  cmake .. ):   -DCMAKE_INSTALL_PREFIX=(path) : Install MoMEMta in a specific location when running  make install  (useful if you don't have admin rights)  -DPROFILING=ON : Generate debugging symbols and profiling information (requires  gperftools )  -DBOOST_ROOT=(path) : Use specific Boost version (path to its install directory)  -DTESTS=ON : Also compile the test executables  -DEXAMPLES=OFF : Do not compile the example executables  -DPYTHON_BINDINGS=ON|OFF  ( OFF  by default). Builds python bindings for MoMEMta. Requires python and boost::python.  -DDEBUG_TIMING=ON|OFF  ( OFF  by default). If  ON , a summary of how long each module ran is printed at the end of the integration. Can be useful to see which module to optimize.", 
            "title": "Build options"
        }, 
        {
            "location": "/getting-started/#usage-lua-momemta", 
            "text": "In MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta!  Computing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors:  #include   momemta/ConfigurationReader.h  #include   momemta/MoMEMta.h  #include   momemta/Types.h  int   main ( int   argc ,   char **   argv )   { \n\n     ConfigurationReader   configuration ( tt_fullyleptonic.lua ); \n     MoMEMta   weight ( configuration . freeze ()); \n\n     momemta :: Particle   electron   {   electron ,   LorentzVector ( 16.17 ,   - 13.79 ,   - 3.43 ,   21.53 ),   - 11   }; \n     momemta :: Particle   bjet1   {   bjet1 ,   LorentzVector ( - 55.79 ,   - 111.59 ,   - 122.14 ,   174.66 ),   5   }; \n     momemta :: Particle   bjet2   {   bjet2 ,   LorentzVector ( - 18.90 ,   10.09 ,   - 0.60 ,   21.43 ),   - 5   }; \n     momemta :: Particle   muon   {   muon ,   LorentzVector ( 71.39 ,   96.01 ,   - 77.25 ,   142.50 ),   13   }; \n\n     std :: vector std :: pair double ,   double   weights   =   weight . computeWeights (   {   electron ,   muon ,   bjet1 ,   bjet2   }   ); \n\n     std :: cout     Result:      weights . at ( 0 ). first      +-      weights . at ( 0 ). second ; \n\n     return   0 ;  }", 
            "title": "Usage: Lua &amp; MoMEMta"
        }, 
        {
            "location": "/getting-started/#examples", 
            "text": "We ship a few example configuration files, along with short scripts computing a single weight: find them in  MoMEMta/examples . To run them, simply call them from the  build  directory:  ./tt_fullyleptonic.exe\n./tt_fullyleptonic_NWA.exe\n./WW_fullyleptonic.exe  A set of more comprehensive examples on how to run MoMEMta can be found in our  Tutorials repository . Each of these examples includes a matrix element generated by our  exporter  (see below), a ROOT file containing a few events, a documented Lua configuration file and a small source code showing how to compute weights for the events in the sample.", 
            "title": "Examples"
        }, 
        {
            "location": "/getting-started/#matrix-elements", 
            "text": "MoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our  Matrix Element Exporter , a plugin for  MadGraph5_aMC@NLO  (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s  README file .   Support for other matrix element generators is planned for futures releases, however nothing prevents plugging in any code returning the matrix element provided it is wrapped properly for MoMEMta.", 
            "title": "Matrix elements"
        }, 
        {
            "location": "/in-depth/calling-momemta/", 
            "text": "In MoMEMta, the integration is defined by linking modules together in a Lua script. MoMEMta is shipped with a set of modules covering the most common needs and whose parameters, inputs and outputs are documented \nhere\n. For more information on how to write the configuration file, see \nhere\n.\n\n\n\n\nNote\n\n\nA module is just a C++ class deriving from the \nModule\n virtual class. You can learn more on how to create your own module and make it available for the calculation \nhere\n\n\n\n\nOnce the configuration file is defined, it can be loaded by MoMEMta\u2019s configuration reader:\n\n\nConfigurationReader\n \nmy_reader\n(\nrelative_path_to_lua_file.lua\n);\n\n\n\n\n\n\nAt this point, the user might wish to modify some parameters defined in the file from the code itself (see also \nhere\n):\n\n\nmy_reader\n.\ngetGlobalParameters\n().\nset\n(\ntop_mass\n,\n \n173.\n);\n\n\n\n\n\n\nThen, MoMEMta can be instantiated using a \"frozen\" configuration set:\n\n\nConfiguration\n \nmy_config\n \n=\n \nmy_reader\n.\nfreeze\n();\n\n\nMoMEMta\n \nweight\n(\nmy_config\n);\n\n\n\n\n\n\n\n\nNote\n\n\nMoMEMta is instantiated using a \nConfiguration\n object, describing a frozen configuration: parameters cannot be modified at this stage, the execution flow of the computation is fully fixed. Parameters can however be changed in the ConfigurationReader, and a new \nMoMEMta\n instance must then be constructed by calling \nConfigurationReader::freeze()\n again.\n\n\n\n\nThe weight can finally be computed by calling the \ncomputeWeights()\n method of the MoMEMta object, passing the observed particles as arguments:\n\n\nROOT\n::\nMath\n::\nLorentzVector\nROOT\n::\nMath\n::\nPxPyPzE4D\ndouble\n \np1\n,\n \np2\n,\n \nmet\n;\n\n\nmomemta\n::\nParticle\n \npart1\n \n{\n \npart1\n,\n \np1\n,\n \n0\n \n};\n\n\nmomemta\n::\nParticle\n \npart2\n \n{\n \npart2\n,\n \np2\n,\n \n0\n \n};\n\n\nstd\n::\nvector\nstd\n::\npair\ndouble\n,\n \ndouble\n \nweights\n \n=\n \nweight\n.\ncomputeWeights\n({\npart1\n,\n \npart2\n},\n \nmet\n);\n\n\n\n\n\n\n\n\nNote\n\n\nThe MET is an optional argument (defaults to a null vector)\n\n\n\n\nThe \nmomemta::Particle\n type consists of three parts: a name (string) allowing to identify the particle in the configuration file, a 4-vector object, and a type (int). The type is not used by MoMEMta at the moment, but is present for future features.\n\n\n\n\nTip\n\n\nMoMEMta provides the useful typedef \nLorentzVector\n for Lorentz Vectors in the file \nmomemta/Types.h\n\n\n\n\n\n\nWarning\n\n\nMoMEMta checks that your inputs are physical, i.e. have non-negative energy and mass. Due e.g. to machine precision issues, it is possible your inputs have slightly negative masses without you noticing it. However, MoMEMta can produce nonsensical output or even crash in this case (\ngarbage in, garbage out\n). It's up to the user to correct the inputs in those cases.\n\n\n\n\nThe function \ncomputeWeights()\n starts the Monte-Carlo integration: the integrand function is called a large number of times, each time passing as input a phase-space point vector (where the length of the vector is the dimensionality of the integrated phase-space) with elements between 0 and 1, and returning as output the integrated function evaluated on this point.\n\n\ncomputeWeights()\n returns a vector of pairs (weight, uncertainty). In most cases, this vector will contain only one entry, but MoMEMta allows the possibility to define \nvector\n integrands, i.e. integrate multi-valued functions, and return a weight and uncertainty for each component.\n\n\nPython bindings\n\n\nCalling MoMEMta from python is also possible, provided the python bindings have been built (see the \nbuild options\n). If you have not installed MoMEMta system-wide but in a user-defined directory (say \nMOMEMTA_DIR\n), you should make sure the two following conditions are satisfied:\n\n\n\n\n$MOMEMTA_DIR/lib[64]/pythonX/site-packages/\n (exact path depends on your system) should be in your \nPYTHONPATH\n\n\n$MOMEMTA_DIR/lib/\n should be in your \nLD_LIBRARY_PATH\n\n\n\n\nThen, you might call MoMEMta from your python analysis script in this manner:\n\n\nimport\n \nmomemta\n\n\n\n# Restrict logging to \nerror\n level\n\n\nmomemta\n.\nset_log_level\n(\nmomemta\n.\nlog_level\n.\nerror\n)\n\n\n\nmomemta_cfg\n \n=\n \nmomemta\n.\nConfigurationReader\n(\npath_to_config.lua\n)\n\n\nmomemta_computer\n \n=\n \nmomemta\n.\nMoMEMta\n(\nmomemta_cfg\n.\nfreeze\n())\n\n\n\n# px, py, pz, E\n\n\np1\n \n=\n \n[\n10\n,\n \n20\n,\n \n30\n,\n \n200\n]\n\n\np2\n \n=\n \n[\n-\n10\n,\n \n20\n,\n \n-\n30\n,\n \n200\n]\n\n\n\n## Using ROOT 4-vectors is also possible\n\n\n# import ROOT\n\n\n# LorentzVector = ROOT.Math.LorentzVector(ROOT.Math.PxPyPzE4D(\ndouble\n))\n\n\n# p1 = LorentzVector(10, 20, 30, 200)\n\n\n# p2 = LorentzVector(-10, 20, -30, 200)\n\n\n\nresult\n \n=\n \nmomemta_computer\n.\ncomputeWeights\n([\np1\n,\n \np2\n])\n\n\nprint\n(\nWeight: {} +- {}\n.\nformat\n(\nresult\n[\n0\n][\n0\n],\n \nresult\n[\n0\n][\n1\n]))\n\n\n\n\n\n\nMore information about the Python bindings can be found in the \ntechnical documentation\n.", 
            "title": "Calling MoMEMta"
        }, 
        {
            "location": "/in-depth/calling-momemta/#python-bindings", 
            "text": "Calling MoMEMta from python is also possible, provided the python bindings have been built (see the  build options ). If you have not installed MoMEMta system-wide but in a user-defined directory (say  MOMEMTA_DIR ), you should make sure the two following conditions are satisfied:   $MOMEMTA_DIR/lib[64]/pythonX/site-packages/  (exact path depends on your system) should be in your  PYTHONPATH  $MOMEMTA_DIR/lib/  should be in your  LD_LIBRARY_PATH   Then, you might call MoMEMta from your python analysis script in this manner:  import   momemta  # Restrict logging to  error  level  momemta . set_log_level ( momemta . log_level . error )  momemta_cfg   =   momemta . ConfigurationReader ( path_to_config.lua )  momemta_computer   =   momemta . MoMEMta ( momemta_cfg . freeze ())  # px, py, pz, E  p1   =   [ 10 ,   20 ,   30 ,   200 ]  p2   =   [ - 10 ,   20 ,   - 30 ,   200 ]  ## Using ROOT 4-vectors is also possible  # import ROOT  # LorentzVector = ROOT.Math.LorentzVector(ROOT.Math.PxPyPzE4D( double ))  # p1 = LorentzVector(10, 20, 30, 200)  # p2 = LorentzVector(-10, 20, -30, 200)  result   =   momemta_computer . computeWeights ([ p1 ,   p2 ])  print ( Weight: {} +- {} . format ( result [ 0 ][ 0 ],   result [ 0 ][ 1 ]))   More information about the Python bindings can be found in the  technical documentation .", 
            "title": "Python bindings"
        }, 
        {
            "location": "/in-depth/configuration-file/", 
            "text": "The configuration file\n\n\nConfiguring modules\n\n\nDifferent \ntypes\n of modules are available on MoMEMta, each designed to perform a specific task. \nDeclaring an instance of a module named \nkarl\n of type \nGaussian\n in Lua is simple:\n\n\nGaussian\n.\nkarl\n \n=\n \n{}\n\n\n\n\n\n\nEach module can be configured by setting its parameters and its inputs:\n\n\nGaussian\n.\nkarl\n \n=\n \n{}\n\n\nGaussian\n.\nfriedrich\n \n=\n \n{\n\n    \n-- Some fixed parameters\n\n    \nage\n \n=\n \n25\n,\n\n    \nsize\n \n=\n \n1.75\n,\n\n    \nplace\n \n=\n \nGottingen\n,\n\n    \ndead\n \n=\n \ntrue\n,\n\n    \n-- Define inputs using other modules\u2019 outputs\n\n    \ninput\n \n=\n \nkarl::output\n\n\n}\n\n\n\n\n\n\nA \nparameter\n is strongly typed and can be an integer (eg.: \n2\n), a floating point number, (eg.: \n172.5\n, \n13000.\n - note the decimal point \nmust\n be present), a boolean (\ntrue\n or \nfalse\n) or a string (eg.: \nhello\n). Parameters might have default values and be optional, or be mandatory.\n\n\nAn \ninput\n is set through a so-called \"\ninput tag\n\" of the form \nother_module::its_output[/i]\n, where \nother_module\n is the name of another module responsible for producing the quantity \nits_output\n, and \n/i\n has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input. \n\n\nSome modules expect \nvectors\n of input tags, where the order of the entries may or may not matter. Vectors in Lua are easily declared:\n\n\n-- Take first and third entry of vector output `output` of module `that_module`\n\n\ninputs\n \n=\n \n{\n \nthat_module::output/1\n,\n \nthat_module::output/3\n \n}\n\n\n\n\n\n\nAccessing entries of previously defined vectors is also possible:\n\n\ntemp_vector\n \n=\n \n{\n \nfirst\n,\n \nsecond\n,\n \nthird\n \n}\n\n\n-- Use only { \nfirst\n, \nthird\n }:\n\n\nmy_inputs\n \n=\n \n{\n \ntemp_vector\n[\n1\n],\n \ntemp_vector\n[\n3\n]\n \n}\n\n\n\n\n\n\n\n\nWarning\n\n\nThe indexing of Lua vectors or input tags starts at \n1, not 0\n.\n\n\n\n\nThe use of some modules requires adding a dimension to the volume that is being integrated over. In other words, those modules need a component of the phase-space points to be specified as input. This is done using the function \nadd_dimension()\n, which returns an input tag linking to a component of the phase-space point, and notifies MoMEMta to add an integration dimension.\n\n\nThe order in which the modules are declared in the script does not matter: MoMEMta automatically executes the modules in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed.\n\n\nA full list of modules available out-of-the-box, along with documentation about the modules' inputs, outputs and parameters, is available at MoMEMta's \ntechnical documentation\n.\n\n\nDeclaring input particles\n\n\nInput particles are declared in the configuration file as:\n\n\nlocal\n \nl_part1\n \n=\n \ndeclare_input\n(\npart1\n)\n \n-- Give that input a name: \npart1\n\n\n\n\n\n\nIn C++, that input's 4-vector can then be passed through the \ncomputeWeights()\n function (see \nCalling MoMEMta\n) by defining a \nmomemta::Particle\n object whose name attribute is the same as the one used in the configuration, e.g. \nmomemta::Particle m_part1 { \"part1\", p1, 0 }\n.\n\n\nThe Lua object \nl_part1\n, via the \nreco_p4\n attribute, contains the input tag needed to access the particle's 4-vector. For instance, defining a transfer function on the energy of \npart1\n can be done as:\n\n\nGaussianTransferFunctionOnEnergy\n.\ntf_part1\n \n=\n \n{\n\n  \nps_point\n \n=\n \nadd_dimension\n(),\n \n-- A transfer function integrates over a variable (the particle\ns energy), so we need a new dimension in the integrated volume\n\n  \nreco_particle\n \n=\n \nl_part1\n.\nreco_p4\n,\n \n-- Pass the input tag corresponding to the experimentally reconstructed 4-vector of the particle, given to \ncomputeWeights()\n\n  \nsigma\n \n=\n \n0.10\n,\n \n-- Take 10% resolution on the energy\n\n  \nsigma_range\n \n=\n \n5\n \n-- Integrate from -5*sigma*E to +5*sigma*E\n\n\n}\n\n\n\n\n\n\nSince the transfer function integrates over the particle's energy, it generates new values for its energy. This defines a new, 'parton'-level 4-vector for \npart1\n, which can now be passed e.g. to a matrix element. In this example, the parton-level 4-vector can be accessed directly through the \ntf_part1::output\n input tag. It is also possible to register it with the \nl_part1\n object:\n\n\nl_part1\n.\nset_gen_p4\n(\ntf_part1::output\n)\n\n\n\n\n\n\nWhen declaring further modules, instead of using \ntf_part1::output\n, it is now possible to use \nl_part1.gen_p4\n to access the parton-level 4-vector, i.e. these are equivalent:\n\n\nP4Printer\n.\nprinter1\n \n=\n \n{\n \ninput\n \n=\n \ntf_part1::output\n \n}\n\n\nP4Printer\n.\nprinter2\n \n=\n \n{\n \ninput\n \n=\n \nl_part1\n.\ngen_p4\n \n}\n\n\n\n\n\n\n\n\nNote\n\n\nIf the function \nset_gen_p4()\n is not called, one has by default \nl_part1.gen_p4 = l_part1.reco_p4\n. For instance, if you don't use transfer functions there is no distinction needed between 'parton'- and 'reco'-level quantities.\n\n\n\n\nThe missing transverse energy 4-vector (passed optionally to \ncomputeWeights()\n) can be accessed directly through the \nmet::p4\n input tag.\n\n\nDeclaring the integrand\n\n\nWhen the integration is fully configured, i.e. the final module computing the integrand value is defined, the integrand has to be registered with MoMEMta to be able to compute the integral. \nFor instance, if the module called \nfinal_module\n with output \noutput\n defines the integrand, one has to call:\n\n\nintegrand\n(\nfinal_module::output\n)\n\n\n\n\n\n\nIt is possible in MoMEMta to integrate multi-valued functions (caution: is only efficient if the components of the function are not too different). For two components, the integrand would then be declared as:\n\n\nintegrand\n(\nfinal_module_1::output\n,\n \nfinal_module_2::output\n)\n\n\n\n\n\n\nIn this case, \ncomputeWeights()\n would return a vector with two entries, embedding the value of the integral and the corresponding uncertainty for each of the two components.", 
            "title": "Configuration file"
        }, 
        {
            "location": "/in-depth/configuration-file/#the-configuration-file", 
            "text": "", 
            "title": "The configuration file"
        }, 
        {
            "location": "/in-depth/configuration-file/#configuring-modules", 
            "text": "Different  types  of modules are available on MoMEMta, each designed to perform a specific task. \nDeclaring an instance of a module named  karl  of type  Gaussian  in Lua is simple:  Gaussian . karl   =   {}   Each module can be configured by setting its parameters and its inputs:  Gaussian . karl   =   {}  Gaussian . friedrich   =   { \n     -- Some fixed parameters \n     age   =   25 , \n     size   =   1.75 , \n     place   =   Gottingen , \n     dead   =   true , \n     -- Define inputs using other modules\u2019 outputs \n     input   =   karl::output  }   A  parameter  is strongly typed and can be an integer (eg.:  2 ), a floating point number, (eg.:  172.5 ,  13000.  - note the decimal point  must  be present), a boolean ( true  or  false ) or a string (eg.:  hello ). Parameters might have default values and be optional, or be mandatory.  An  input  is set through a so-called \" input tag \" of the form  other_module::its_output[/i] , where  other_module  is the name of another module responsible for producing the quantity  its_output , and  /i  has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input.   Some modules expect  vectors  of input tags, where the order of the entries may or may not matter. Vectors in Lua are easily declared:  -- Take first and third entry of vector output `output` of module `that_module`  inputs   =   {   that_module::output/1 ,   that_module::output/3   }   Accessing entries of previously defined vectors is also possible:  temp_vector   =   {   first ,   second ,   third   }  -- Use only {  first ,  third  }:  my_inputs   =   {   temp_vector [ 1 ],   temp_vector [ 3 ]   }    Warning  The indexing of Lua vectors or input tags starts at  1, not 0 .   The use of some modules requires adding a dimension to the volume that is being integrated over. In other words, those modules need a component of the phase-space points to be specified as input. This is done using the function  add_dimension() , which returns an input tag linking to a component of the phase-space point, and notifies MoMEMta to add an integration dimension.  The order in which the modules are declared in the script does not matter: MoMEMta automatically executes the modules in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed.  A full list of modules available out-of-the-box, along with documentation about the modules' inputs, outputs and parameters, is available at MoMEMta's  technical documentation .", 
            "title": "Configuring modules"
        }, 
        {
            "location": "/in-depth/configuration-file/#declaring-input-particles", 
            "text": "Input particles are declared in the configuration file as:  local   l_part1   =   declare_input ( part1 )   -- Give that input a name:  part1   In C++, that input's 4-vector can then be passed through the  computeWeights()  function (see  Calling MoMEMta ) by defining a  momemta::Particle  object whose name attribute is the same as the one used in the configuration, e.g.  momemta::Particle m_part1 { \"part1\", p1, 0 } .  The Lua object  l_part1 , via the  reco_p4  attribute, contains the input tag needed to access the particle's 4-vector. For instance, defining a transfer function on the energy of  part1  can be done as:  GaussianTransferFunctionOnEnergy . tf_part1   =   { \n   ps_point   =   add_dimension (),   -- A transfer function integrates over a variable (the particle s energy), so we need a new dimension in the integrated volume \n   reco_particle   =   l_part1 . reco_p4 ,   -- Pass the input tag corresponding to the experimentally reconstructed 4-vector of the particle, given to  computeWeights() \n   sigma   =   0.10 ,   -- Take 10% resolution on the energy \n   sigma_range   =   5   -- Integrate from -5*sigma*E to +5*sigma*E  }   Since the transfer function integrates over the particle's energy, it generates new values for its energy. This defines a new, 'parton'-level 4-vector for  part1 , which can now be passed e.g. to a matrix element. In this example, the parton-level 4-vector can be accessed directly through the  tf_part1::output  input tag. It is also possible to register it with the  l_part1  object:  l_part1 . set_gen_p4 ( tf_part1::output )   When declaring further modules, instead of using  tf_part1::output , it is now possible to use  l_part1.gen_p4  to access the parton-level 4-vector, i.e. these are equivalent:  P4Printer . printer1   =   {   input   =   tf_part1::output   }  P4Printer . printer2   =   {   input   =   l_part1 . gen_p4   }    Note  If the function  set_gen_p4()  is not called, one has by default  l_part1.gen_p4 = l_part1.reco_p4 . For instance, if you don't use transfer functions there is no distinction needed between 'parton'- and 'reco'-level quantities.   The missing transverse energy 4-vector (passed optionally to  computeWeights() ) can be accessed directly through the  met::p4  input tag.", 
            "title": "Declaring input particles"
        }, 
        {
            "location": "/in-depth/configuration-file/#declaring-the-integrand", 
            "text": "When the integration is fully configured, i.e. the final module computing the integrand value is defined, the integrand has to be registered with MoMEMta to be able to compute the integral. \nFor instance, if the module called  final_module  with output  output  defines the integrand, one has to call:  integrand ( final_module::output )   It is possible in MoMEMta to integrate multi-valued functions (caution: is only efficient if the components of the function are not too different). For two components, the integrand would then be declared as:  integrand ( final_module_1::output ,   final_module_2::output )   In this case,  computeWeights()  would return a vector with two entries, embedding the value of the integral and the corresponding uncertainty for each of the two components.", 
            "title": "Declaring the integrand"
        }, 
        {
            "location": "/in-depth/parameters/", 
            "text": "Defining parameters\n\n\nIn MoMEMta, once the \nConfigurationReader\n has been \"frozen\" to give a \nConfiguration\n object, it is not possible anymore to modify anything in the integration. However, some parameters can be modified in the \nConfigurationReader\n from the C++ code (allowing e.g. to carry out mass scans easily). In order to do that, the parameters have to be put in the special \nparameters\n table in Lua:\n\n\nparameters\n \n=\n \n{\n\n  \nmy_mass\n \n=\n \n173.\n,\n\n  \nmy_width\n \n=\n \n2.5\n\n\n}\n\n\n\n\n\n\nThese parameters can then be linked with the modules' parameters using the \nparameter()\n Lua function:\n\n\nBreitWignerGenerator\n.\nm_prop\n \n=\n \n{\n\n  \nps_point\n \n=\n \nadd_dimension\n(),\n\n  \nmass\n \n=\n \nparameter\n(\nmy_mass\n),\n \n-- Access the value through the \nparameter\n function, allowing it to be modified from the C++ code\n\n  \nwidth\n \n=\n \nparameters\n.\nmy_width\n \n-- Access the value as a regular Lua table. It will NOT be possible to modify it later on\n\n\n}\n\n\n\n\n\n\n\n\nDanger\n\n\nAccessing the parameter entries directly, as \nparameters.my_width\n or \nparameters['my_width']\n, makes it impossible to modify them from the C++ code. The latter is only possible when using the \nparameter()\n function.\n\n\n\n\nList of existing parameters\n\n\nIn addition to parameters accessible to modules, some parameters are read directly by MoMEMta and can influence its behavior. You can find the full list below:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexport_graph_as\n\n\nAny file name\n\n\nNone\n\n\nSet this parameter to any value to export the computation graph built by MoMEMta. This is useful to visually see how your weight is computed.\n\n\n\n\n\n\n\n\nConfiguring the integration algorithm\n\n\nThe integration algorithm can be configured from within Lua using the \ncuba\n table, for instance:\n\n\ncuba\n \n=\n \n{\n\n  \nalgorithm\n \n=\n \ndivonne\n,\n \n-- default is \nvegas\n\n  \nrelative_accuracy\n \n=\n \n0.01\n\n\n}\n\n\n\n\n\n\nFour different integration algorithms are available, and each has several parameters than can be tweaked to adjust their behaviour, tweak the precision of the calculations, ...\nThe integration parameters can be changed from the C++ in a manner similar to the \"global\" parameters (see \nprevious section\n), using the method \nConfigurationReader::getCubaConfiguration()\n.\nThe available algorithms and corresponding options are briefly listed here; for a full description, please consult the documentation of the numerical integration library used in MoMEMta: Cuba\n1\n. \n\n\nBear in mind the default values for these parameters are not guaranteed to be optimal for your particular case! It's your job to ensure the algorithm is tweaked to work well for the events and the functions you'll be integrating.\n\n\nIntegration algorithm:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nalgorithm\n\n\nvegas\n, \nsuave\n, \ndivonne\n, \ncuhre\n\n\nvegas\n\n\n\n\n\n\n\n\nCommon arguments:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nrelative_accuracy\n\n\nfloats\n\n\n0.005\n\n\n\n\n\n\nabsolute_accuracy\n\n\nfloats\n\n\n0.\n\n\n\n\n\n\nseed\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nmin_eval\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nmax_eval\n\n\nintegers\n\n\n500000\n\n\n\n\n\n\ngrid_file\n\n\npaths\n\n\n\n\n\n\n\n\nverbosity\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nsubregion\n\n\nbooleans\n\n\nfalse\n\n\n\n\n\n\nretainStateFile\n\n\nbooleans\n\n\nfalse\n\n\n\n\n\n\nlevels\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nncores\n\n\nintegers\n\n\n0\n\n\n\n\n\n\npcores\n\n\nintegers\n\n\n1000000\n\n\n\n\n\n\n\n\nVegas-specific arguments:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\ntakeOnlyGridFromFile\n\n\nbooleans\n\n\ntrue\n\n\n\n\n\n\nn_start\n\n\nintegers\n\n\n25000\n\n\n\n\n\n\nn_increase\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nbatch_size\n\n\nintegers\n\n\nmin(n_start, 50000)\n\n\n\n\n\n\ngrid_number\n\n\nintegers\n\n\n0\n\n\n\n\n\n\nsmoothing\n\n\nbooleans\n\n\ntrue\n\n\n\n\n\n\n\n\nSuave-specific arguments:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nn_new\n\n\nintegers\n\n\n1000\n\n\n\n\n\n\nn_min\n\n\nintegers\n\n\n2\n\n\n\n\n\n\nflatness\n\n\nfloats\n\n\n0.25\n\n\n\n\n\n\n\n\nDivonne-specific arguments:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nkey1\n\n\nintegers\n\n\n47\n\n\n\n\n\n\nkey2\n\n\nintegers\n\n\n1\n\n\n\n\n\n\nkey3\n\n\nintegers\n\n\n1\n\n\n\n\n\n\nmaxpass\n\n\nintegers\n\n\n5\n\n\n\n\n\n\nborder\n\n\nfloats\n\n\n0.\n\n\n\n\n\n\nmaxchisq\n\n\nfloats\n\n\n10.\n\n\n\n\n\n\nmindeviation\n\n\nfloats\n\n\n0.25\n\n\n\n\n\n\n\n\nCuhre-specific arguments:\n\n\n\n\n\n\n\n\nParameter\n\n\nAllowed values\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nintegers\n\n\n0\n\n\n\n\n\n\n\n\nPassing arguments to the configuration\n\n\nOnce the \nConfigurationReader\n has parsed the Lua configuration file, it is not possible anymore to change the resulting computation flow (the only changes possible are the above parameters). \nIt is however possible to pass arguments from C++ to the Lua script when it is read by the \nConfigurationReader\n, to influence its execution. \n\n\nDefining the arguments in C++:\n\n\nParameterSet\n \nlua_parameters\n;\n\n\nlua_parameters\n.\nset\n(\ntext1\n,\n \nhello, world!\n);\n\n\nlua_parameters\n.\nset\n(\ntext2\n,\n \nalways look on the bright side of life!\n);\n\n\nlua_parameters\n.\nset\n(\nquestion\n,\n \ntrue\n);\n\n\nConfigurationReader\n \nconfiguration\n(\nexample.lua\n,\n \nlua_parameters\n);\n\n\n\n\n\n\nMakes them available in Lua, i.e.:\n\n\nif\n \nquestion\n \nthen\n\n  \nprint\n(\ntest1\n)\n\n\nelse\n\n  \nprint\n(\ntest2\n)\n\n\nend\n\n\n\n\n\n\nWould print \"hello, world!\".\n\n\n\n\n\n\n\n\n\n\nT. Hahn, \n\"Cuba - a library for multidimensional numerical integration\"", 
            "title": "Parameters"
        }, 
        {
            "location": "/in-depth/parameters/#defining-parameters", 
            "text": "In MoMEMta, once the  ConfigurationReader  has been \"frozen\" to give a  Configuration  object, it is not possible anymore to modify anything in the integration. However, some parameters can be modified in the  ConfigurationReader  from the C++ code (allowing e.g. to carry out mass scans easily). In order to do that, the parameters have to be put in the special  parameters  table in Lua:  parameters   =   { \n   my_mass   =   173. , \n   my_width   =   2.5  }   These parameters can then be linked with the modules' parameters using the  parameter()  Lua function:  BreitWignerGenerator . m_prop   =   { \n   ps_point   =   add_dimension (), \n   mass   =   parameter ( my_mass ),   -- Access the value through the  parameter  function, allowing it to be modified from the C++ code \n   width   =   parameters . my_width   -- Access the value as a regular Lua table. It will NOT be possible to modify it later on  }    Danger  Accessing the parameter entries directly, as  parameters.my_width  or  parameters['my_width'] , makes it impossible to modify them from the C++ code. The latter is only possible when using the  parameter()  function.", 
            "title": "Defining parameters"
        }, 
        {
            "location": "/in-depth/parameters/#list-of-existing-parameters", 
            "text": "In addition to parameters accessible to modules, some parameters are read directly by MoMEMta and can influence its behavior. You can find the full list below:     Parameter  Allowed values  Default value  Description      export_graph_as  Any file name  None  Set this parameter to any value to export the computation graph built by MoMEMta. This is useful to visually see how your weight is computed.", 
            "title": "List of existing parameters"
        }, 
        {
            "location": "/in-depth/parameters/#configuring-the-integration-algorithm", 
            "text": "The integration algorithm can be configured from within Lua using the  cuba  table, for instance:  cuba   =   { \n   algorithm   =   divonne ,   -- default is  vegas \n   relative_accuracy   =   0.01  }   Four different integration algorithms are available, and each has several parameters than can be tweaked to adjust their behaviour, tweak the precision of the calculations, ...\nThe integration parameters can be changed from the C++ in a manner similar to the \"global\" parameters (see  previous section ), using the method  ConfigurationReader::getCubaConfiguration() .\nThe available algorithms and corresponding options are briefly listed here; for a full description, please consult the documentation of the numerical integration library used in MoMEMta: Cuba 1 .   Bear in mind the default values for these parameters are not guaranteed to be optimal for your particular case! It's your job to ensure the algorithm is tweaked to work well for the events and the functions you'll be integrating.  Integration algorithm:     Parameter  Allowed values  Default value      algorithm  vegas ,  suave ,  divonne ,  cuhre  vegas     Common arguments:     Parameter  Allowed values  Default value      relative_accuracy  floats  0.005    absolute_accuracy  floats  0.    seed  integers  0    min_eval  integers  0    max_eval  integers  500000    grid_file  paths     verbosity  integers  0    subregion  booleans  false    retainStateFile  booleans  false    levels  integers  0    ncores  integers  0    pcores  integers  1000000     Vegas-specific arguments:     Parameter  Allowed values  Default value      takeOnlyGridFromFile  booleans  true    n_start  integers  25000    n_increase  integers  0    batch_size  integers  min(n_start, 50000)    grid_number  integers  0    smoothing  booleans  true     Suave-specific arguments:     Parameter  Allowed values  Default value      n_new  integers  1000    n_min  integers  2    flatness  floats  0.25     Divonne-specific arguments:     Parameter  Allowed values  Default value      key1  integers  47    key2  integers  1    key3  integers  1    maxpass  integers  5    border  floats  0.    maxchisq  floats  10.    mindeviation  floats  0.25     Cuhre-specific arguments:     Parameter  Allowed values  Default value      key  integers  0", 
            "title": "Configuring the integration algorithm"
        }, 
        {
            "location": "/in-depth/parameters/#passing-arguments-to-the-configuration", 
            "text": "Once the  ConfigurationReader  has parsed the Lua configuration file, it is not possible anymore to change the resulting computation flow (the only changes possible are the above parameters). \nIt is however possible to pass arguments from C++ to the Lua script when it is read by the  ConfigurationReader , to influence its execution.   Defining the arguments in C++:  ParameterSet   lua_parameters ;  lua_parameters . set ( text1 ,   hello, world! );  lua_parameters . set ( text2 ,   always look on the bright side of life! );  lua_parameters . set ( question ,   true );  ConfigurationReader   configuration ( example.lua ,   lua_parameters );   Makes them available in Lua, i.e.:  if   question   then \n   print ( test1 )  else \n   print ( test2 )  end   Would print \"hello, world!\".      T. Hahn,  \"Cuba - a library for multidimensional numerical integration\"", 
            "title": "Passing arguments to the configuration"
        }, 
        {
            "location": "/in-depth/new-module/", 
            "text": "Adding a new module\n\n\nYou can easily extend MoMEMta by adding new modules to perform operations not supported by the base modules.\n\n\nDefining the module's interface\n\n\nYou declare a new module in MoMEMta by subclassing the \nModule class\n, and then registering the new module into the MoMEMta system.\n\n\nLet's suppose you want to declare a new module printing \nHello world!\n at each step of the integration. You first need to include the right header:\n\n\n#include\n \nmomemta/Module.h\n\n\n\n\n\n\nand then to subclass the \nModule\n class:\n\n\nclass\n \nHelloWorldModule\n:\n \npublic\n \nModule\n \n{\n\n\n\n};\n\n\n\n\n\n\nIf you want your new module to be useful, you'll want to override some specific functions, starting by the constructor and the \nwork\n function:\n\n\nclass\n \nHelloWorldModule\n:\n \npublic\n \nModule\n \n{\n\n\npublic\n:\n\n  \nHelloWorldModule\n(\nPoolPtr\n \npool\n,\n \nconst\n \nParameterSet\n \nparameters\n)\n:\n \nModule\n(\npool\n,\n \nparameters\n.\ngetModuleName\n())\n \n{\n \n}\n\n\n  \nvirtual\n \nStatus\n \nwork\n()\n \noverride\n \n{\n\n    \nstd\n::\ncout\n \n \nHello world!\n \n \nstd\n::\nendl\n;\n\n\n    \nreturn\n \nStatus\n::\nOK\n;\n\n  \n}\n\n\n};\n\n\n\n\n\n\nThe \nwork\n function is called by MoMEMta each time the integrand needs to be evaluated (thousand times per integration). With this code, our module would only output the string \nHello world!\n and not produce anything useful, but it's fine, that's what we wanted! The only remaining thing is to register the new module into the system.\n\n\nRegistering the module\n\n\nBefore being available to MoMEMta, a module must be registered into the system. This is done using the \nREGISTER_MODULE\n macro. After the declaration of your module, simply add:\n\n\nREGISTER_MODULE\n(\nHelloWorldModule\n)\n\n    \n.\nSticky\n();\n\n\n\n\n\n\nBecause your module does not produce any output, MoMEMta will automatically remove it from the computation graph, since it does not contribute in any way to the final integrand value. You can prevent this behaviour by registering your module as \nsticky\n: a \nsticky\n module is not removed from the computation graph if it's found to not contribute.\n\n\nLoading the module\n\n\nSo, you have successfully defined a new module and registered it with the system. In order to use it during the computation of the weight, you first have to \nload\n the shared library where your module is.\n\n\nLet's suppose your module is contained into \nlibhelloworldmodule.so\n. In the lua configuration file, you need to first instruct MoMEMta to load this library to gain access to the new module:\n\n\nload_modules\n(\nlibhelloworldmodule.so\n)\n\n\n\n\n\n\nYou can now use your new module as you would do for a built-in module:\n\n\nHelloWorldModule\n.\nhello\n \n=\n \n{}\n\n\n\n\n\n\nUsing advanced features into your module\n\n\nThe module we built before is nice, but not very useful. Ideally, our module wants to gather some input data, transform them and output new data that in turn can be used by other modules. So we need two features: a way to get \ninputs\n and a way to produce \noutputs\n.\n\n\nInputs and outputs\n\n\nA module retrieves its inputs from the memory pool. The only moment the pool is accessible is during the construction of the module (see the first argument of the constructor). The \nPool\n class\n has a \nget\n method you must use to obtain a pointer to the input. The \nget\n method accepts only a single argument, the \nInputTag\n of the input to grab.\n\n\n\n\nWarning\n\n\nInputs can only be accessed inside the \nwork\n method. Trying to access to an input in another method will result in an undefined behaviour.\n\n\n\n\nLet's edit our \nHello, world!\n module to retrieve an input:\n\n\nclass\n \nHelloWorldModule\n:\n \npublic\n \nModule\n \n{\n\n\npublic\n:\n\n  \nHelloWorldModule\n(\nPoolPtr\n \npool\n,\n \nconst\n \nParameterSet\n \nparameters\n)\n:\n \nModule\n(\npool\n,\n \nparameters\n.\ngetModuleName\n())\n \n{\n\n    \ninput\n \n=\n \npool\n-\nget\ndouble\n(\nInputTag\n(\nmodule\n,\n \noutput\n));\n\n\n    \noutput\n \n=\n \nproduce\ndouble\n(\nmy_output\n);\n\n  \n}\n\n\n  \nvirtual\n \nStatus\n \nwork\n()\n \noverride\n \n{\n\n    \nstd\n::\ncout\n \n \nHello world!\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \nOur input is: \n \n \n*\ninput\n \n \nstd\n::\nendl\n;\n\n\n    \n*\noutput\n \n=\n \n*\ninput\n \n*\n \n2\n;\n\n\n    \nreturn\n \nStatus\n::\nOK\n;\n\n  \n}\n\n\n\nprivate\n:\n\n  \nValue\ndouble\n \ninput\n;\n\n\n  \nstd\n::\nshared_ptr\ndouble\n \noutput\n;\n\n\n};\n\n\n\n\n\n\nFirst addition registers an output named \nmy_output\n for this module, of type \ndouble\n. The second addition sets the value of the output to be twice the input value.\n\n\nParameters\n\n\nIn the above example, we hardcoded the \nInputTag\n used to retrieve the input. This is not a good practice, because you can't know when writing your module how the user will want to use your module and which output he wants to connect to your module. To overcome this, you can use the parameters (second argument of the constructor) to get data specified by the user inside the configuration file. In our example here, we can request the user to tell, inside the configuration, how he wants to connect our module by letting him specify the \nInputTag\n to use.\n\n\nParameters are stored into a \nParameterSet\n, which is simply a dictionary of heterogeneous types. You can access values using the \nget\n function, specifying the name of the parameter you want.\n\n\n\n\nNote\n\n\nOnly a subset of types are supported by \nParameterSet\n. You can only store and retrieve \nint64_t\n (integers), \ndouble\n (floating point numbers), \nbool\n, \nstd::string\n, \nInputTag\n, \nParameterSet\n, as well as \nstd::vector\n of any of the previous types.\n\n\n\n\nWe will modify our module to remove the hardcoded \nInputTag\n and require the user to pass it as a parameter:\n\n\nclass\n \nHelloWorldModule\n:\n \npublic\n \nModule\n \n{\n\n\npublic\n:\n\n  \nHelloWorldModule\n(\nPoolPtr\n \npool\n,\n \nconst\n \nParameterSet\n \nparameters\n)\n:\n \nModule\n(\npool\n,\n \nparameters\n.\ngetModuleName\n())\n \n{\n\n\n    \nInputTag\n \ninputTag\n \n=\n \nparameters\n.\nget\nInputTag\n(\nwhich_input\n);\n\n\n    \ninput\n \n=\n \npool\n-\nget\ndouble\n(\ninputTag\n);\n\n\n\n    \noutput\n \n=\n \nproduce\ndouble\n(\nmy_output\n);\n\n  \n}\n\n\n  \nvirtual\n \nStatus\n \nwork\n()\n \noverride\n \n{\n\n    \nstd\n::\ncout\n \n \nHello world!\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \nOur input is: \n \n \n*\ninput\n \n \nstd\n::\nendl\n;\n\n\n    \n*\noutput\n \n=\n \n*\ninput\n \n*\n \n2\n;\n\n\n    \nreturn\n \nStatus\n::\nOK\n;\n\n  \n}\n\n\n\nprivate\n:\n\n  \nValue\ndouble\n \ninput\n;\n\n\n  \nstd\n::\nshared_ptr\ndouble\n \noutput\n;\n\n\n};\n\n\n\n\n\n\nYou can now see it's a two-step process to retrieve an input:\n\n\n\n\nWe retrieve the parameter \nwhich_input\n of type \nInputTag\n, specified by the user inside the configuration file.\n\n\nWe use this \nInputTag\n to retrieve our input.\n\n\n\n\nOn the configuration side, the user must now specify a value for the \nwhich_input\n parameter:\n\n\nHelloWorldModule\n.\nhello\n \n=\n \n{\n\n  \nwhich_input\n \n=\n \nmodule::output\n\n\n}\n\n\n\n\n\n\n\n\nTip\n\n\nYou can provide a default value when retrieving an argument. This value will be returned if the parameter is not found in the set.\n\n\n\n\n\n\nTip\n\n\nYou can use the \nexists\n method of \nParameterSet\n to check if a given parameter exists.\n\n\n\n\nModule registration\n\n\nWhen using inputs, outputs or parameters in your modules, extra steps are needed during the registration to inform the system what are your module expectations.\n\n\nREGISTER_MODULE\n(\nHelloWorldModule\n)\n\n    \n.\nInput\n(\nwhich_input\n)\n\n    \n.\nOutput\n(\noutput\n);\n\n\n\n\n\n\nThe above declaration informs the system that your module has one input (\nwhich_input\n) and one output (\noutput\n). MoMEMta now expects the user to specify a value for \nwhich_input\n when writing the configuration file, and, more specifically, this value must be an \nInputTag\n.\n\n\nAttributes\n\n\nAttributes are any parameters which are not inputs. They are used to pass parameters to the module, like for example the current center of mass energy, or the mass of a particle.\n\n\nYou define an attribute when you register the module, by specifying its name and type using the \nAttr\n or \nOptionalAttr\n methods, which expect a spec of the form:\n\n\nname\n: \ntype-expr\n = \ndefault\n\n\n\n\n\n\nwhere \nname\n begins with a letter and can be composed of alphanumeric characters and underscores, and \ntype-expr\nis a type expression of the form \ndescribed below\n. An optional \ndefault\n value can also be specified. If it's the case, the attribute is automatically marked as optional.\n\n\nLet's imagine our module needs to know what's the mass of the top quark to work. We need to add a new attribute of type \ndouble\n:\n\n\nREGISTER_MODULE\n(\nHelloWorldModule\n)\n\n    \n.\nAttr\n(\nmass: double\n)\n\n    \n.\nInput\n(\nwhich_input\n)\n\n    \n.\nOutput\n(\noutput\n);\n\n\n\n\n\n\nSupported types\n\n\nThe following types are supported when registering a new attribute:\n\n\n\n\nint\n: signed 64-bits integer\n\n\ndouble\n: 64-bits floating point number\n\n\nstring\n: sequence of characters\n\n\nbool\n: true or false\n\n\npset\n: a ParameterSet\n\n\nlist(\ntype\n)\n: a list of any of the types above.\n\n\n\n\n\n\nWarning\n\n\nAn \nInputTag\n attribute is an \ninput\n, not an attribute. As a consequence, \nInputTag\n is \nnot\n a valid type for an attribute.\n\n\n\n\n\n\nDanger\n\n\nNo check is currently performed to ensure only valid types are passed as attributes in the configuration file. Full support is planned for future release.\n\n\n\n\nInputs and outputs\n\n\nInputs and outputs are untyped. To register inputs, you can use the \nInput\n method. For an output, use the \nOutput\n method. These methods expect a spec of the form:\n\n\n[\nattr\n/]*\nname\n\n\n\n\n\n\nname\n begins with a letter and can be composed of alphanumeric characters and underscores. In the case of inputs only, you can also describe where the \nInputTag\n must be fetched using \nattr\n. \nattr\n must refer to an existing attribute (defined with the \nAttr\n method) of type \npset\n. More than one level of nesting is possible.\n\n\nHere's an example illustrating this feature:\n\n\nREGISTER_MODULE\n(\nHelloWorldModule\n)\n\n    \n.\nAttr\n(\nmass: double\n)\n\n\n    \n.\nAttr\n(\ndata: pset\n)\n\n\n    \n.\nInput\n(\nfirst_input\n)\n\n\n    \n.\nInput\n(\ndata/second_input\n)\n\n\n    \n.\nOutput\n(\noutput\n);\n\n\n\n\n\n\nThis imaginary module needs two inputs: \nfirst_input\n will be fetched from the main parameters, while \nsecond_input\n will be fetched from the \ndata\n attribute. You can configure such module the following way:\n\n\nHelloWorldModule\n.\nhello\n \n=\n \n{\n\n  \nmass\n \n=\n \n173.0\n,\n\n  \ndata\n \n=\n \n{\n\n    \nsecond_input\n \n=\n \nmodule::second_output\n\n  \n},\n\n  \nfirst_input\n \n=\n \nmodule::first_output\n\n\n}\n\n\n\n\n\n\nMore\n\n\nThe sources of the built-in modules are a good source of documentation too. Those can be found \non our github repository", 
            "title": "Adding a new module"
        }, 
        {
            "location": "/in-depth/new-module/#adding-a-new-module", 
            "text": "You can easily extend MoMEMta by adding new modules to perform operations not supported by the base modules.", 
            "title": "Adding a new module"
        }, 
        {
            "location": "/in-depth/new-module/#defining-the-modules-interface", 
            "text": "You declare a new module in MoMEMta by subclassing the  Module class , and then registering the new module into the MoMEMta system.  Let's suppose you want to declare a new module printing  Hello world!  at each step of the integration. You first need to include the right header:  #include   momemta/Module.h   and then to subclass the  Module  class:  class   HelloWorldModule :   public   Module   {  };   If you want your new module to be useful, you'll want to override some specific functions, starting by the constructor and the  work  function:  class   HelloWorldModule :   public   Module   {  public : \n   HelloWorldModule ( PoolPtr   pool ,   const   ParameterSet   parameters ) :   Module ( pool ,   parameters . getModuleName ())   {   } \n\n   virtual   Status   work ()   override   { \n     std :: cout     Hello world!     std :: endl ; \n\n     return   Status :: OK ; \n   }  };   The  work  function is called by MoMEMta each time the integrand needs to be evaluated (thousand times per integration). With this code, our module would only output the string  Hello world!  and not produce anything useful, but it's fine, that's what we wanted! The only remaining thing is to register the new module into the system.", 
            "title": "Defining the module's interface"
        }, 
        {
            "location": "/in-depth/new-module/#registering-the-module", 
            "text": "Before being available to MoMEMta, a module must be registered into the system. This is done using the  REGISTER_MODULE  macro. After the declaration of your module, simply add:  REGISTER_MODULE ( HelloWorldModule ) \n     . Sticky ();   Because your module does not produce any output, MoMEMta will automatically remove it from the computation graph, since it does not contribute in any way to the final integrand value. You can prevent this behaviour by registering your module as  sticky : a  sticky  module is not removed from the computation graph if it's found to not contribute.", 
            "title": "Registering the module"
        }, 
        {
            "location": "/in-depth/new-module/#loading-the-module", 
            "text": "So, you have successfully defined a new module and registered it with the system. In order to use it during the computation of the weight, you first have to  load  the shared library where your module is.  Let's suppose your module is contained into  libhelloworldmodule.so . In the lua configuration file, you need to first instruct MoMEMta to load this library to gain access to the new module:  load_modules ( libhelloworldmodule.so )   You can now use your new module as you would do for a built-in module:  HelloWorldModule . hello   =   {}", 
            "title": "Loading the module"
        }, 
        {
            "location": "/in-depth/new-module/#using-advanced-features-into-your-module", 
            "text": "The module we built before is nice, but not very useful. Ideally, our module wants to gather some input data, transform them and output new data that in turn can be used by other modules. So we need two features: a way to get  inputs  and a way to produce  outputs .", 
            "title": "Using advanced features into your module"
        }, 
        {
            "location": "/in-depth/new-module/#inputs-and-outputs", 
            "text": "A module retrieves its inputs from the memory pool. The only moment the pool is accessible is during the construction of the module (see the first argument of the constructor). The  Pool  class  has a  get  method you must use to obtain a pointer to the input. The  get  method accepts only a single argument, the  InputTag  of the input to grab.   Warning  Inputs can only be accessed inside the  work  method. Trying to access to an input in another method will result in an undefined behaviour.   Let's edit our  Hello, world!  module to retrieve an input:  class   HelloWorldModule :   public   Module   {  public : \n   HelloWorldModule ( PoolPtr   pool ,   const   ParameterSet   parameters ) :   Module ( pool ,   parameters . getModuleName ())   { \n     input   =   pool - get double ( InputTag ( module ,   output )); \n\n     output   =   produce double ( my_output ); \n   } \n\n   virtual   Status   work ()   override   { \n     std :: cout     Hello world!     std :: endl ; \n     std :: cout     Our input is:      * input     std :: endl ; \n\n     * output   =   * input   *   2 ; \n\n     return   Status :: OK ; \n   }  private : \n   Value double   input ; \n\n   std :: shared_ptr double   output ;  };   First addition registers an output named  my_output  for this module, of type  double . The second addition sets the value of the output to be twice the input value.", 
            "title": "Inputs and outputs"
        }, 
        {
            "location": "/in-depth/new-module/#parameters", 
            "text": "In the above example, we hardcoded the  InputTag  used to retrieve the input. This is not a good practice, because you can't know when writing your module how the user will want to use your module and which output he wants to connect to your module. To overcome this, you can use the parameters (second argument of the constructor) to get data specified by the user inside the configuration file. In our example here, we can request the user to tell, inside the configuration, how he wants to connect our module by letting him specify the  InputTag  to use.  Parameters are stored into a  ParameterSet , which is simply a dictionary of heterogeneous types. You can access values using the  get  function, specifying the name of the parameter you want.   Note  Only a subset of types are supported by  ParameterSet . You can only store and retrieve  int64_t  (integers),  double  (floating point numbers),  bool ,  std::string ,  InputTag ,  ParameterSet , as well as  std::vector  of any of the previous types.   We will modify our module to remove the hardcoded  InputTag  and require the user to pass it as a parameter:  class   HelloWorldModule :   public   Module   {  public : \n   HelloWorldModule ( PoolPtr   pool ,   const   ParameterSet   parameters ) :   Module ( pool ,   parameters . getModuleName ())   {       InputTag   inputTag   =   parameters . get InputTag ( which_input );       input   =   pool - get double ( inputTag );  \n     output   =   produce double ( my_output ); \n   } \n\n   virtual   Status   work ()   override   { \n     std :: cout     Hello world!     std :: endl ; \n     std :: cout     Our input is:      * input     std :: endl ; \n\n     * output   =   * input   *   2 ; \n\n     return   Status :: OK ; \n   }  private : \n   Value double   input ; \n\n   std :: shared_ptr double   output ;  };   You can now see it's a two-step process to retrieve an input:   We retrieve the parameter  which_input  of type  InputTag , specified by the user inside the configuration file.  We use this  InputTag  to retrieve our input.   On the configuration side, the user must now specify a value for the  which_input  parameter:  HelloWorldModule . hello   =   { \n   which_input   =   module::output  }    Tip  You can provide a default value when retrieving an argument. This value will be returned if the parameter is not found in the set.    Tip  You can use the  exists  method of  ParameterSet  to check if a given parameter exists.", 
            "title": "Parameters"
        }, 
        {
            "location": "/in-depth/new-module/#module-registration", 
            "text": "When using inputs, outputs or parameters in your modules, extra steps are needed during the registration to inform the system what are your module expectations.  REGISTER_MODULE ( HelloWorldModule ) \n     . Input ( which_input ) \n     . Output ( output );   The above declaration informs the system that your module has one input ( which_input ) and one output ( output ). MoMEMta now expects the user to specify a value for  which_input  when writing the configuration file, and, more specifically, this value must be an  InputTag .", 
            "title": "Module registration"
        }, 
        {
            "location": "/in-depth/new-module/#attributes", 
            "text": "Attributes are any parameters which are not inputs. They are used to pass parameters to the module, like for example the current center of mass energy, or the mass of a particle.  You define an attribute when you register the module, by specifying its name and type using the  Attr  or  OptionalAttr  methods, which expect a spec of the form:  name :  type-expr  =  default   where  name  begins with a letter and can be composed of alphanumeric characters and underscores, and  type-expr is a type expression of the form  described below . An optional  default  value can also be specified. If it's the case, the attribute is automatically marked as optional.  Let's imagine our module needs to know what's the mass of the top quark to work. We need to add a new attribute of type  double :  REGISTER_MODULE ( HelloWorldModule ) \n     . Attr ( mass: double ) \n     . Input ( which_input ) \n     . Output ( output );", 
            "title": "Attributes"
        }, 
        {
            "location": "/in-depth/new-module/#supported-types", 
            "text": "The following types are supported when registering a new attribute:   int : signed 64-bits integer  double : 64-bits floating point number  string : sequence of characters  bool : true or false  pset : a ParameterSet  list( type ) : a list of any of the types above.    Warning  An  InputTag  attribute is an  input , not an attribute. As a consequence,  InputTag  is  not  a valid type for an attribute.    Danger  No check is currently performed to ensure only valid types are passed as attributes in the configuration file. Full support is planned for future release.", 
            "title": "Supported types"
        }, 
        {
            "location": "/in-depth/new-module/#inputs-and-outputs_1", 
            "text": "Inputs and outputs are untyped. To register inputs, you can use the  Input  method. For an output, use the  Output  method. These methods expect a spec of the form:  [ attr /]* name   name  begins with a letter and can be composed of alphanumeric characters and underscores. In the case of inputs only, you can also describe where the  InputTag  must be fetched using  attr .  attr  must refer to an existing attribute (defined with the  Attr  method) of type  pset . More than one level of nesting is possible.  Here's an example illustrating this feature:  REGISTER_MODULE ( HelloWorldModule ) \n     . Attr ( mass: double )       . Attr ( data: pset )       . Input ( first_input )       . Input ( data/second_input )       . Output ( output );   This imaginary module needs two inputs:  first_input  will be fetched from the main parameters, while  second_input  will be fetched from the  data  attribute. You can configure such module the following way:  HelloWorldModule . hello   =   { \n   mass   =   173.0 , \n   data   =   { \n     second_input   =   module::second_output \n   }, \n   first_input   =   module::first_output  }", 
            "title": "Inputs and outputs"
        }, 
        {
            "location": "/in-depth/new-module/#more", 
            "text": "The sources of the built-in modules are a good source of documentation too. Those can be found  on our github repository", 
            "title": "More"
        }, 
        {
            "location": "/in-depth/validation/", 
            "text": "Validation\n\n\nThe phase-space parametrisations in terms of blocks are validated using two differents methods:\n\n\n\n\nComputation of a cross-section\n: the block is used to compute the cross-section of a given process. The result is then compared to the cross-section computed using MadGraph\n1\n for the same process.\n\n\nComputation of a phase-space volume\n: only the phase-space density is integrated (no PDF or matrix element), and the result is compared with the analytical result for production of \nn\n massless particles at a hadronic centre-of-mass energy of \n\\sqrt{s}\n GeV: \n  \n\n    V(\\sqrt{s}, n) = \\frac{s^{n-3}}{2^{4(n-1)} \\pi^{2n-3} (n-1) (n-2)^2 ((n-2)!)^2}\n  \n\n\n\n\n\n\nIn both cases, MoMEMta's phase-space parametrisations are not efficient for the problem, but by increasing the number of integrand evaluations to a very large number, sufficient precision can be reached nonetheless.\n\n\nBlock A\n\n\nCross-section\n\n\nThe process used is \npp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}\n\n\n\n\n\n\nMadGraph cross-section: \n0.866(5)\n pb\n\n\nMoMEMta cross-section: \n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 3 massless particles at \n\\sqrt{s} = 1\n TeV\n\n\n\n\nTheoretical phase-space volume: \n6.3 \\cdot 10^{-15}\n\n\n\n\nMoMEMta phase-space volume: \n6.299(6) \\cdot 10^{-15}\n\n\n\n\n\n\nBlock B\n\n\nCross-section\n\n\nThe process used is \npp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}\n\n\n\n\n\n\nMadGraph cross-section: \n0.866(5)\n pb\n\n\nMoMEMta cross-section: \n0.868(8)\n pb\n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 3 massless particles at \n\\sqrt{s} = 1\n TeV\n\n\n\n\nTheoretical phase-space volume: \n6.3 \\cdot 10^{-15}\n\n\n\n\nMoMEMta phase-space volume: \n6.297(6) \\cdot 10^{-15}\n\n\n\n\n\n\nBlock D\n\n\nThe process used is \npp \\rightarrow t\\bar{t}\n fully-leptonic\n\n\n\n\nMadGraph cross-section: \n6.73(2)\n pb\n\n\nMoMEMta cross-section: \n6.69(3)\n pb\n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 6 massless particles at \n\\sqrt{s} = 1\n TeV\n\n\n\n\nTheoretical phase-space volume : \n694 \\text{GeV}^6\n\n\n\n\nMoMEMta phase-space volume: \n695(4) \\text{GeV}^6\n\n\n\n\n\n\nBlock F\n\n\nCross-section\n\n\nThe process used is \npp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}\n\n\n\n\n\n\nMadGraph cross-section: \n0.866(5)\n pb\n\n\nMoMEMta cross-section: \n0.864(4)\n pb\n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 4 massless particles at \n\\sqrt{s} = 1\n TeV\n\n\n\n\nTheoretical phase-space volume: \n0.0166 \\text{GeV}^2\n\n\n\n\nMoMEMta phase-space volume: \n0.0166(3) \\text{GeV}^2\n\n\n\n\n\n\nBlock G\n\n\nCross-section\n\n\nThe process used is \npp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}\n\n\n\n\n\n\nMadGraph cross-section: \n0.866(5)\n pb\n\n\nMoMEMta cross-section: \n0.864(4)\n pb\n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 4 massless particles at \n\\sqrt{s} = 1\n TeV\n\n\n\n\nTheoretical phase-space volume: \n0.0166 \\text{GeV}^2\n\n\n\n\nMoMEMta phase-space volume: \n0.01659(3) \\text{GeV}^2\n\n\n\n\n\n\nSecondary Block C/D\n\n\nCross-section\n\n\nThe process used is \npp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}\n \n Main block used for computation: B\n\n\n\n\nMadGraph cross-section: \n0.866(5)\n pb\n\n\nMoMEMta cross-section: \n0.868(8)\n pb\n\n\n\n\nPhase-space volume\n\n\nVolume computed: production of 4 massless particles at \n\\sqrt{s} = 1\n TeV \n Main block used for computation: A\n\n\n\n\nTheoretical phase-space volume: \n0.0166\n\n\n\\text{GeV}^2\n\n\n\n\nMoMEMta phase-space volume: \n0.01663(6) \\text{GeV}^2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJ. Alwall et al., \n\u201cThe automated computation of tree-level and next-to-leading order differential cross sections, and their matching to parton shower simulations\u201d\n, JHEP \n07\n (2014) \n079", 
            "title": "Validation"
        }, 
        {
            "location": "/in-depth/validation/#validation", 
            "text": "The phase-space parametrisations in terms of blocks are validated using two differents methods:   Computation of a cross-section : the block is used to compute the cross-section of a given process. The result is then compared to the cross-section computed using MadGraph 1  for the same process.  Computation of a phase-space volume : only the phase-space density is integrated (no PDF or matrix element), and the result is compared with the analytical result for production of  n  massless particles at a hadronic centre-of-mass energy of  \\sqrt{s}  GeV: \n   \n    V(\\sqrt{s}, n) = \\frac{s^{n-3}}{2^{4(n-1)} \\pi^{2n-3} (n-1) (n-2)^2 ((n-2)!)^2}\n      In both cases, MoMEMta's phase-space parametrisations are not efficient for the problem, but by increasing the number of integrand evaluations to a very large number, sufficient precision can be reached nonetheless.", 
            "title": "Validation"
        }, 
        {
            "location": "/in-depth/validation/#block-a", 
            "text": "", 
            "title": "Block A"
        }, 
        {
            "location": "/in-depth/validation/#cross-section", 
            "text": "The process used is  pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}    MadGraph cross-section:  0.866(5)  pb  MoMEMta cross-section:", 
            "title": "Cross-section"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume", 
            "text": "Volume computed: production of 3 massless particles at  \\sqrt{s} = 1  TeV   Theoretical phase-space volume:  6.3 \\cdot 10^{-15}   MoMEMta phase-space volume:  6.299(6) \\cdot 10^{-15}", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/in-depth/validation/#block-b", 
            "text": "", 
            "title": "Block B"
        }, 
        {
            "location": "/in-depth/validation/#cross-section_1", 
            "text": "The process used is  pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}    MadGraph cross-section:  0.866(5)  pb  MoMEMta cross-section:  0.868(8)  pb", 
            "title": "Cross-section"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume_1", 
            "text": "Volume computed: production of 3 massless particles at  \\sqrt{s} = 1  TeV   Theoretical phase-space volume:  6.3 \\cdot 10^{-15}   MoMEMta phase-space volume:  6.297(6) \\cdot 10^{-15}", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/in-depth/validation/#block-d", 
            "text": "The process used is  pp \\rightarrow t\\bar{t}  fully-leptonic   MadGraph cross-section:  6.73(2)  pb  MoMEMta cross-section:  6.69(3)  pb", 
            "title": "Block D"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume_2", 
            "text": "Volume computed: production of 6 massless particles at  \\sqrt{s} = 1  TeV   Theoretical phase-space volume :  694 \\text{GeV}^6   MoMEMta phase-space volume:  695(4) \\text{GeV}^6", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/in-depth/validation/#block-f", 
            "text": "", 
            "title": "Block F"
        }, 
        {
            "location": "/in-depth/validation/#cross-section_2", 
            "text": "The process used is  pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}    MadGraph cross-section:  0.866(5)  pb  MoMEMta cross-section:  0.864(4)  pb", 
            "title": "Cross-section"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume_3", 
            "text": "Volume computed: production of 4 massless particles at  \\sqrt{s} = 1  TeV   Theoretical phase-space volume:  0.0166 \\text{GeV}^2   MoMEMta phase-space volume:  0.0166(3) \\text{GeV}^2", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/in-depth/validation/#block-g", 
            "text": "", 
            "title": "Block G"
        }, 
        {
            "location": "/in-depth/validation/#cross-section_3", 
            "text": "The process used is  pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}    MadGraph cross-section:  0.866(5)  pb  MoMEMta cross-section:  0.864(4)  pb", 
            "title": "Cross-section"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume_4", 
            "text": "Volume computed: production of 4 massless particles at  \\sqrt{s} = 1  TeV   Theoretical phase-space volume:  0.0166 \\text{GeV}^2   MoMEMta phase-space volume:  0.01659(3) \\text{GeV}^2", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/in-depth/validation/#secondary-block-cd", 
            "text": "", 
            "title": "Secondary Block C/D"
        }, 
        {
            "location": "/in-depth/validation/#cross-section_4", 
            "text": "The process used is  pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu}    Main block used for computation: B   MadGraph cross-section:  0.866(5)  pb  MoMEMta cross-section:  0.868(8)  pb", 
            "title": "Cross-section"
        }, 
        {
            "location": "/in-depth/validation/#phase-space-volume_5", 
            "text": "Volume computed: production of 4 massless particles at  \\sqrt{s} = 1  TeV   Main block used for computation: A   Theoretical phase-space volume:  0.0166  \\text{GeV}^2   MoMEMta phase-space volume:  0.01663(6) \\text{GeV}^2        J. Alwall et al.,  \u201cThe automated computation of tree-level and next-to-leading order differential cross sections, and their matching to parton shower simulations\u201d , JHEP  07  (2014)  079", 
            "title": "Phase-space volume"
        }, 
        {
            "location": "/changelog/", 
            "text": "1.0.0\n - 2018-05-22\n\n\nAdded\n\n\n\n\nInterface to evaluate the integrand on a phase-space point (\nMoMEMta::setEvent\n and \nMoMEMta::evaluateIntegrand\n functions).\n\n\nSupport for python3 - new build options as a consequence: \nPYTHON_MIN_VERSION\n and \nBoost_PYTHON_VERSION_TAG\n.\n\n\n\n\nChanged\n\n\n\n\nMinimum CMake version is now 3.4.0.\n\n\n\n\nFixed\n\n\n\n\nBuild on systems where default compiler standard is C++14 (fixed conflict with ROOT enforcing the use of exactly the same standard as the one it was built with).\n\n\nProblem in some module definitions (BinnedTransferFunctionOnEnergy, BinnedTransferFunctionOnPt, BlockB, BlockD): outputs and attributes did not correspond with module registry.\n\n\nBug in graph creation, visible only when several instances of MoMEMta were created.\n\n\nLHAPDF could not be found in a CMSSW environment (\nlhapdf-config\n not available)\n\n\n\n\n1.0.0 beta 1\n - 2017-31-08\n\n\nAdded\n\n\n\n\nNew \nLooper\n module to loop over a set of solutions (see below for more details)\n\n\nPython bindings. To enable, pass \n-DPYTHON_BINDINGS=ON\n to \ncmake\n.\n\n\nModules to only evaluate transfer functions (without integrating over anything): BinnedTransferFunctionOnEnergyEvaluator, GaussianTransferFunctionOnEnergyEvaluator\n\n\nMatrix element parameters can now be edited from the configuration file.\n\n\nConfigurationReader\n constructor now accepts an optional second argument allowing the definition of variables accessible from the lua configuration. \n\n\nWhen an exception occurs while constructing a module, try to give useful information to help debugging.\n\n\nSupport for CMSSW environment. Python, boost and LHAPDF libraries from CMSSW are automatically used and running \nmake install\n will automatically register MoMEMta as a new external tool.\n\n\nSupport use of other integration algorithms implemented in Cuba (Suave, Divonne, Cuhre)\n\n\nBinned and Gaussian transfer function on Pt\n\n\nDEBUG_TIMING\n cmake option, to print a summary of each module runtime at the end of the integration.\n\n\nNew cuba option to configure multi-core integration, \nncores\n and \npcores\n.\n\n\ndeclare_input\n lua function, used to declare a new input.\n\n\nappend\n and \ncopy_and_append\n lua functions are now built-in MoMEMta.\n\n\nTwo new lua functions, \nadd_reco_permutations\n and \nadd_gen_permutations\n are available to easily insert a permutator module permutating between the function arguments. \n\n\nLinearCombinator\n templated module allowing to compute combinations (ie sums, subtractions, ...) of LorentzVectors, numbers, ...\n\n\nSecondary blocks A, B, CD, E\n\n\nMain blocks A, C, E and G (not present in MadWeight)\n\n\ngetRandom4Vector\n function to generate random Lorentz vectors of a specified mass (useful in cases where a particle has to be passed from C++, but integrated over all its components).\n\n\n\n\nChanged\n\n\n\n\nThe way to handle multiple solutions coming from blocks has changed. A module is no longer responsible for looping over the solutions itself, this role is delegated to the \nLooper\n module. As a consequence, most of the module were rewritten to handle this change. See this \npull request\n and \nthis one\n for a more technical description, and this \ndocumentation entry\n for more details\n\n\nThe way input tags corresponding to phase-space points are defined in Lua has changed. It is no longer allowed to specify them explicitly (through \ncuba::ps_point/i\n). The function \ngetpspoint()\n has been changed to \nadd_dimension()\n and should be used each time an additional dimension is needed for the integration (the function returns an input tag for the corresponding phase-space components). Modules do not declare how many dimensions they need (counting the number of dimensions is done automatically through the \nadd_dimension()\n function). See this \nPull Request\n for more details.\n\n\nGaussianTransferFunction renamed to GaussianTransferFunctionOnEnergy to be consistent. Also, the width of the Gaussian is computed from the 'gen' energy, not the 'reco' (more correct). The width over which the integration is performed, however, is still computed using the 'reco' energy (no choice there): i.e. integrating over +/- 5 sigma with a resolution of 10% gives an integration range of 'E_gen' in +/- 5*0.1*E_reco.\n\n\nCuba \nsmoothing\n option is now enabled by default to mitigate numerical instabilities during the integration. See \nthis\n for more details.\n\n\nIf no integration dimension is requested, no integration is performed and the graph is only evaluated once. As such, no error is provided on the final result.\n\n\nCuba logging is now handled by MoMEMta logger, at \ndebug\n level.\n\n\nWe no longer use boost-log for logging, but our own implementation heavily inspired by \nspdlog\n. As a consequence, boost-log is no longer required to build MoMEMta.\n\n\nBoost is no longer a dependency when \nusing\n MoMEMta (but it's still a build dependency)\n\n\nMoMEMta::computeWeights\n now expects a vector of \nParticle\n and no longer a vector of \nLorentzVector\n. A \nParticle\n has a name, a \nLorentzVector\n and a type. As a result, configuration files must now declare which inputs are expected.\n\n\nThe way the inputs are passed to the blocks is changed (the particles entering the change of variables are set explicitly, the others are put into the \nbranches\n vector of input tags)\n\n\nBuilt-in lua version is now v5.3.4\n\n\nBlock B, D and F: support massive invisible particles\n\n\n\n\nFixed\n\n\n\n\nCuba forking mode was broken when building in release mode (with \n-DCMAKE_RELEASE_TYPE=Release\n).\n\n\nSLHA card reader (matrix element parameter cards) retrieved from MadGraph was broken.\n\n\nTransfer functions on energy take as lower bound the mass of the given \"reco\" particle", 
            "title": "Release notes"
        }, 
        {
            "location": "/changelog/#100-2018-05-22", 
            "text": "", 
            "title": "1.0.0 - 2018-05-22"
        }, 
        {
            "location": "/changelog/#added", 
            "text": "Interface to evaluate the integrand on a phase-space point ( MoMEMta::setEvent  and  MoMEMta::evaluateIntegrand  functions).  Support for python3 - new build options as a consequence:  PYTHON_MIN_VERSION  and  Boost_PYTHON_VERSION_TAG .", 
            "title": "Added"
        }, 
        {
            "location": "/changelog/#changed", 
            "text": "Minimum CMake version is now 3.4.0.", 
            "title": "Changed"
        }, 
        {
            "location": "/changelog/#fixed", 
            "text": "Build on systems where default compiler standard is C++14 (fixed conflict with ROOT enforcing the use of exactly the same standard as the one it was built with).  Problem in some module definitions (BinnedTransferFunctionOnEnergy, BinnedTransferFunctionOnPt, BlockB, BlockD): outputs and attributes did not correspond with module registry.  Bug in graph creation, visible only when several instances of MoMEMta were created.  LHAPDF could not be found in a CMSSW environment ( lhapdf-config  not available)", 
            "title": "Fixed"
        }, 
        {
            "location": "/changelog/#100-beta-1-2017-31-08", 
            "text": "", 
            "title": "1.0.0 beta 1 - 2017-31-08"
        }, 
        {
            "location": "/changelog/#added_1", 
            "text": "New  Looper  module to loop over a set of solutions (see below for more details)  Python bindings. To enable, pass  -DPYTHON_BINDINGS=ON  to  cmake .  Modules to only evaluate transfer functions (without integrating over anything): BinnedTransferFunctionOnEnergyEvaluator, GaussianTransferFunctionOnEnergyEvaluator  Matrix element parameters can now be edited from the configuration file.  ConfigurationReader  constructor now accepts an optional second argument allowing the definition of variables accessible from the lua configuration.   When an exception occurs while constructing a module, try to give useful information to help debugging.  Support for CMSSW environment. Python, boost and LHAPDF libraries from CMSSW are automatically used and running  make install  will automatically register MoMEMta as a new external tool.  Support use of other integration algorithms implemented in Cuba (Suave, Divonne, Cuhre)  Binned and Gaussian transfer function on Pt  DEBUG_TIMING  cmake option, to print a summary of each module runtime at the end of the integration.  New cuba option to configure multi-core integration,  ncores  and  pcores .  declare_input  lua function, used to declare a new input.  append  and  copy_and_append  lua functions are now built-in MoMEMta.  Two new lua functions,  add_reco_permutations  and  add_gen_permutations  are available to easily insert a permutator module permutating between the function arguments.   LinearCombinator  templated module allowing to compute combinations (ie sums, subtractions, ...) of LorentzVectors, numbers, ...  Secondary blocks A, B, CD, E  Main blocks A, C, E and G (not present in MadWeight)  getRandom4Vector  function to generate random Lorentz vectors of a specified mass (useful in cases where a particle has to be passed from C++, but integrated over all its components).", 
            "title": "Added"
        }, 
        {
            "location": "/changelog/#changed_1", 
            "text": "The way to handle multiple solutions coming from blocks has changed. A module is no longer responsible for looping over the solutions itself, this role is delegated to the  Looper  module. As a consequence, most of the module were rewritten to handle this change. See this  pull request  and  this one  for a more technical description, and this  documentation entry  for more details  The way input tags corresponding to phase-space points are defined in Lua has changed. It is no longer allowed to specify them explicitly (through  cuba::ps_point/i ). The function  getpspoint()  has been changed to  add_dimension()  and should be used each time an additional dimension is needed for the integration (the function returns an input tag for the corresponding phase-space components). Modules do not declare how many dimensions they need (counting the number of dimensions is done automatically through the  add_dimension()  function). See this  Pull Request  for more details.  GaussianTransferFunction renamed to GaussianTransferFunctionOnEnergy to be consistent. Also, the width of the Gaussian is computed from the 'gen' energy, not the 'reco' (more correct). The width over which the integration is performed, however, is still computed using the 'reco' energy (no choice there): i.e. integrating over +/- 5 sigma with a resolution of 10% gives an integration range of 'E_gen' in +/- 5*0.1*E_reco.  Cuba  smoothing  option is now enabled by default to mitigate numerical instabilities during the integration. See  this  for more details.  If no integration dimension is requested, no integration is performed and the graph is only evaluated once. As such, no error is provided on the final result.  Cuba logging is now handled by MoMEMta logger, at  debug  level.  We no longer use boost-log for logging, but our own implementation heavily inspired by  spdlog . As a consequence, boost-log is no longer required to build MoMEMta.  Boost is no longer a dependency when  using  MoMEMta (but it's still a build dependency)  MoMEMta::computeWeights  now expects a vector of  Particle  and no longer a vector of  LorentzVector . A  Particle  has a name, a  LorentzVector  and a type. As a result, configuration files must now declare which inputs are expected.  The way the inputs are passed to the blocks is changed (the particles entering the change of variables are set explicitly, the others are put into the  branches  vector of input tags)  Built-in lua version is now v5.3.4  Block B, D and F: support massive invisible particles", 
            "title": "Changed"
        }, 
        {
            "location": "/changelog/#fixed_1", 
            "text": "Cuba forking mode was broken when building in release mode (with  -DCMAKE_RELEASE_TYPE=Release ).  SLHA card reader (matrix element parameter cards) retrieved from MadGraph was broken.  Transfer functions on energy take as lower bound the mass of the given \"reco\" particle", 
            "title": "Fixed"
        }
    ]
}