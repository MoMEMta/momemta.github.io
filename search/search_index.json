{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The MoMEMta project \u00b6 MoMEMta is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for some common final states ( \\text{t}\\bar{\\text{t}} , WW, \u2026). Expert user or not, be prepared to feel the freedom of configuring your MEM computation at all levels! Note If you're using MoMEMta for your research, please make sure you're citing our reference paper ! MoMEMta is based on: C++, ROOT , Lua scripting language Cuba (Monte-Carlo integration library) External PDFs ( LHAPDF by default) External Matrix Elements (currently provided by our MadGraph C++ exporter plugin ) You will probably want to start with our getting started guide , or check out our set of working examples . Our team \u00b6 S\u00e9bastien Brochet Brieuc Fran\u00e7ois Alessia Saggio Miguel Vidal S\u00e9bastien Wertz Special thanks to Matthias Komm who designed our logo! Acknowledgements \u00b6 This work would not have been possible without the help of the MadWeight team and funding of: MoMEMta is part of a project that has received funding from the European Horizon 2020 research and innovation programme under grant agreement N\u00b0675440.","title":"The MoMEMta project"},{"location":"#the-momemta-project","text":"MoMEMta is a C++ software package to compute Matrix Element weights. Designed in a modular way, it covers the needs of experimental analysis workflows at the LHC. MoMEMta provides working examples for some common final states ( \\text{t}\\bar{\\text{t}} , WW, \u2026). Expert user or not, be prepared to feel the freedom of configuring your MEM computation at all levels! Note If you're using MoMEMta for your research, please make sure you're citing our reference paper ! MoMEMta is based on: C++, ROOT , Lua scripting language Cuba (Monte-Carlo integration library) External PDFs ( LHAPDF by default) External Matrix Elements (currently provided by our MadGraph C++ exporter plugin ) You will probably want to start with our getting started guide , or check out our set of working examples .","title":"The MoMEMta project"},{"location":"#our-team","text":"S\u00e9bastien Brochet Brieuc Fran\u00e7ois Alessia Saggio Miguel Vidal S\u00e9bastien Wertz Special thanks to Matthias Komm who designed our logo!","title":"Our team"},{"location":"#acknowledgements","text":"This work would not have been possible without the help of the MadWeight team and funding of: MoMEMta is part of a project that has received funding from the European Horizon 2020 research and innovation programme under grant agreement N\u00b0675440.","title":"Acknowledgements"},{"location":"changelog/","text":"1.0.0 - 2018-05-22 \u00b6 Added \u00b6 Interface to evaluate the integrand on a phase-space point ( MoMEMta::setEvent and MoMEMta::evaluateIntegrand functions). Support for python3 - new build options as a consequence: PYTHON_MIN_VERSION and Boost_PYTHON_VERSION_TAG . Changed \u00b6 Minimum CMake version is now 3.4.0. Fixed \u00b6 Build on systems where default compiler standard is C++14 (fixed conflict with ROOT enforcing the use of exactly the same standard as the one it was built with). Problem in some module definitions (BinnedTransferFunctionOnEnergy, BinnedTransferFunctionOnPt, BlockB, BlockD): outputs and attributes did not correspond with module registry. Bug in graph creation, visible only when several instances of MoMEMta were created. LHAPDF could not be found in a CMSSW environment ( lhapdf-config not available) 1.0.0 beta 1 - 2017-31-08 \u00b6 Added \u00b6 New Looper module to loop over a set of solutions (see below for more details) Python bindings. To enable, pass -DPYTHON_BINDINGS=ON to cmake . Modules to only evaluate transfer functions (without integrating over anything): BinnedTransferFunctionOnEnergyEvaluator, GaussianTransferFunctionOnEnergyEvaluator Matrix element parameters can now be edited from the configuration file. ConfigurationReader constructor now accepts an optional second argument allowing the definition of variables accessible from the lua configuration. When an exception occurs while constructing a module, try to give useful information to help debugging. Support for CMSSW environment. Python, boost and LHAPDF libraries from CMSSW are automatically used and running make install will automatically register MoMEMta as a new external tool. Support use of other integration algorithms implemented in Cuba (Suave, Divonne, Cuhre) Binned and Gaussian transfer function on Pt DEBUG_TIMING cmake option, to print a summary of each module runtime at the end of the integration. New cuba option to configure multi-core integration, ncores and pcores . declare_input lua function, used to declare a new input. append and copy_and_append lua functions are now built-in MoMEMta. Two new lua functions, add_reco_permutations and add_gen_permutations are available to easily insert a permutator module permutating between the function arguments. LinearCombinator templated module allowing to compute combinations (ie sums, subtractions, ...) of LorentzVectors, numbers, ... Secondary blocks A, B, CD, E Main blocks A, C, E and G (not present in MadWeight) getRandom4Vector function to generate random Lorentz vectors of a specified mass (useful in cases where a particle has to be passed from C++, but integrated over all its components). Changed \u00b6 The way to handle multiple solutions coming from blocks has changed. A module is no longer responsible for looping over the solutions itself, this role is delegated to the Looper module. As a consequence, most of the module were rewritten to handle this change. See this pull request and this one for a more technical description, and this documentation entry for more details The way input tags corresponding to phase-space points are defined in Lua has changed. It is no longer allowed to specify them explicitly (through cuba::ps_point/i ). The function getpspoint() has been changed to add_dimension() and should be used each time an additional dimension is needed for the integration (the function returns an input tag for the corresponding phase-space components). Modules do not declare how many dimensions they need (counting the number of dimensions is done automatically through the add_dimension() function). See this Pull Request for more details. GaussianTransferFunction renamed to GaussianTransferFunctionOnEnergy to be consistent. Also, the width of the Gaussian is computed from the 'gen' energy, not the 'reco' (more correct). The width over which the integration is performed, however, is still computed using the 'reco' energy (no choice there): i.e. integrating over +/- 5 sigma with a resolution of 10% gives an integration range of 'E_gen' in +/- 5*0.1*E_reco. Cuba smoothing option is now enabled by default to mitigate numerical instabilities during the integration. See this for more details. If no integration dimension is requested, no integration is performed and the graph is only evaluated once. As such, no error is provided on the final result. Cuba logging is now handled by MoMEMta logger, at debug level. We no longer use boost-log for logging, but our own implementation heavily inspired by spdlog . As a consequence, boost-log is no longer required to build MoMEMta. Boost is no longer a dependency when using MoMEMta (but it's still a build dependency) MoMEMta::computeWeights now expects a vector of Particle and no longer a vector of LorentzVector . A Particle has a name, a LorentzVector and a type. As a result, configuration files must now declare which inputs are expected. The way the inputs are passed to the blocks is changed (the particles entering the change of variables are set explicitly, the others are put into the branches vector of input tags) Built-in lua version is now v5.3.4 Block B, D and F: support massive invisible particles Fixed \u00b6 Cuba forking mode was broken when building in release mode (with -DCMAKE_RELEASE_TYPE=Release ). SLHA card reader (matrix element parameter cards) retrieved from MadGraph was broken. Transfer functions on energy take as lower bound the mass of the given \"reco\" particle","title":"Release notes"},{"location":"changelog/#100-2018-05-22","text":"","title":"1.0.0 - 2018-05-22"},{"location":"changelog/#added","text":"Interface to evaluate the integrand on a phase-space point ( MoMEMta::setEvent and MoMEMta::evaluateIntegrand functions). Support for python3 - new build options as a consequence: PYTHON_MIN_VERSION and Boost_PYTHON_VERSION_TAG .","title":"Added"},{"location":"changelog/#changed","text":"Minimum CMake version is now 3.4.0.","title":"Changed"},{"location":"changelog/#fixed","text":"Build on systems where default compiler standard is C++14 (fixed conflict with ROOT enforcing the use of exactly the same standard as the one it was built with). Problem in some module definitions (BinnedTransferFunctionOnEnergy, BinnedTransferFunctionOnPt, BlockB, BlockD): outputs and attributes did not correspond with module registry. Bug in graph creation, visible only when several instances of MoMEMta were created. LHAPDF could not be found in a CMSSW environment ( lhapdf-config not available)","title":"Fixed"},{"location":"changelog/#100-beta-1-2017-31-08","text":"","title":"1.0.0 beta 1 - 2017-31-08"},{"location":"changelog/#added_1","text":"New Looper module to loop over a set of solutions (see below for more details) Python bindings. To enable, pass -DPYTHON_BINDINGS=ON to cmake . Modules to only evaluate transfer functions (without integrating over anything): BinnedTransferFunctionOnEnergyEvaluator, GaussianTransferFunctionOnEnergyEvaluator Matrix element parameters can now be edited from the configuration file. ConfigurationReader constructor now accepts an optional second argument allowing the definition of variables accessible from the lua configuration. When an exception occurs while constructing a module, try to give useful information to help debugging. Support for CMSSW environment. Python, boost and LHAPDF libraries from CMSSW are automatically used and running make install will automatically register MoMEMta as a new external tool. Support use of other integration algorithms implemented in Cuba (Suave, Divonne, Cuhre) Binned and Gaussian transfer function on Pt DEBUG_TIMING cmake option, to print a summary of each module runtime at the end of the integration. New cuba option to configure multi-core integration, ncores and pcores . declare_input lua function, used to declare a new input. append and copy_and_append lua functions are now built-in MoMEMta. Two new lua functions, add_reco_permutations and add_gen_permutations are available to easily insert a permutator module permutating between the function arguments. LinearCombinator templated module allowing to compute combinations (ie sums, subtractions, ...) of LorentzVectors, numbers, ... Secondary blocks A, B, CD, E Main blocks A, C, E and G (not present in MadWeight) getRandom4Vector function to generate random Lorentz vectors of a specified mass (useful in cases where a particle has to be passed from C++, but integrated over all its components).","title":"Added"},{"location":"changelog/#changed_1","text":"The way to handle multiple solutions coming from blocks has changed. A module is no longer responsible for looping over the solutions itself, this role is delegated to the Looper module. As a consequence, most of the module were rewritten to handle this change. See this pull request and this one for a more technical description, and this documentation entry for more details The way input tags corresponding to phase-space points are defined in Lua has changed. It is no longer allowed to specify them explicitly (through cuba::ps_point/i ). The function getpspoint() has been changed to add_dimension() and should be used each time an additional dimension is needed for the integration (the function returns an input tag for the corresponding phase-space components). Modules do not declare how many dimensions they need (counting the number of dimensions is done automatically through the add_dimension() function). See this Pull Request for more details. GaussianTransferFunction renamed to GaussianTransferFunctionOnEnergy to be consistent. Also, the width of the Gaussian is computed from the 'gen' energy, not the 'reco' (more correct). The width over which the integration is performed, however, is still computed using the 'reco' energy (no choice there): i.e. integrating over +/- 5 sigma with a resolution of 10% gives an integration range of 'E_gen' in +/- 5*0.1*E_reco. Cuba smoothing option is now enabled by default to mitigate numerical instabilities during the integration. See this for more details. If no integration dimension is requested, no integration is performed and the graph is only evaluated once. As such, no error is provided on the final result. Cuba logging is now handled by MoMEMta logger, at debug level. We no longer use boost-log for logging, but our own implementation heavily inspired by spdlog . As a consequence, boost-log is no longer required to build MoMEMta. Boost is no longer a dependency when using MoMEMta (but it's still a build dependency) MoMEMta::computeWeights now expects a vector of Particle and no longer a vector of LorentzVector . A Particle has a name, a LorentzVector and a type. As a result, configuration files must now declare which inputs are expected. The way the inputs are passed to the blocks is changed (the particles entering the change of variables are set explicitly, the others are put into the branches vector of input tags) Built-in lua version is now v5.3.4 Block B, D and F: support massive invisible particles","title":"Changed"},{"location":"changelog/#fixed_1","text":"Cuba forking mode was broken when building in release mode (with -DCMAKE_RELEASE_TYPE=Release ). SLHA card reader (matrix element parameter cards) retrieved from MadGraph was broken. Transfer functions on energy take as lower bound the mass of the given \"reco\" particle","title":"Fixed"},{"location":"getting-started/","text":"Getting started \u00b6 Installation \u00b6 Prerequisites \u00b6 MoMEMta depends on the following libraries and tools: LHAPDF (>=6) CMake (>=3.2) Boost (>=1.54) ROOT (>=5.34.09) A C++11-capable compiler Note MoMEMta has only been tested on GNU/Linux. Compilation \u00b6 Retrieve the code on our github repository . Unpack the archive and / or go to the MoMEMta directory. Next, execute the following (unless one of the build options described below apply to your case): mkdir build cd build cmake .. make -j 4 Finally, make MoMEMta (public headers and library) available using: make install You can now use MoMEMta with your own code. Build options \u00b6 The following options are available when configuring the build (when running cmake .. ): -DCMAKE_INSTALL_PREFIX=(path) : Install MoMEMta in a specific location when running make install (useful if you don't have admin rights) -DPROFILING=ON : Generate debugging symbols and profiling information (requires gperftools ) -DBOOST_ROOT=(path) : Use specific Boost version (path to its install directory) -DTESTS=ON : Also compile the test executables -DEXAMPLES=OFF : Do not compile the example executables -DPYTHON_BINDINGS=ON|OFF ( OFF by default). Builds python bindings for MoMEMta. Requires python and boost::python. -DDEBUG_TIMING=ON|OFF ( OFF by default). If ON , a summary of how long each module ran is printed at the end of the integration. Can be useful to see which module to optimize. Usage: Lua & MoMEMta \u00b6 In MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta! Computing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors: #include <momemta/ConfigurationReader.h> #include <momemta/MoMEMta.h> #include <momemta/Types.h> int main ( int argc , char ** argv ) { ConfigurationReader configuration ( \"tt_fullyleptonic.lua\" ); MoMEMta weight ( configuration . freeze ()); momemta :: Particle electron { \"electron\" , LorentzVector ( 16.17 , - 13.79 , - 3.43 , 21.53 ), - 11 }; momemta :: Particle bjet1 { \"bjet1\" , LorentzVector ( - 55.79 , - 111.59 , - 122.14 , 174.66 ), 5 }; momemta :: Particle bjet2 { \"bjet2\" , LorentzVector ( - 18.90 , 10.09 , - 0.60 , 21.43 ), - 5 }; momemta :: Particle muon { \"muon\" , LorentzVector ( 71.39 , 96.01 , - 77.25 , 142.50 ), 13 }; std :: vector < std :: pair < double , double >> weights = weight . computeWeights ( { electron , muon , bjet1 , bjet2 } ); std :: cout << \"Result: \" << weights . at ( 0 ). first << \" +- \" << weights . at ( 0 ). second ; return 0 ; } Examples \u00b6 We ship a few example configuration files, along with short scripts computing a single weight: find them in MoMEMta/examples . To run them, simply call them from the build directory: ./tt_fullyleptonic.exe ./tt_fullyleptonic_NWA.exe ./WW_fullyleptonic.exe A set of more comprehensive examples on how to run MoMEMta can be found in our Tutorials repository . Each of these examples includes a matrix element generated by our exporter (see below), a ROOT file containing a few events, a documented Lua configuration file and a small source code showing how to compute weights for the events in the sample. Matrix elements \u00b6 MoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our Matrix Element Exporter , a plugin for MadGraph5_aMC@NLO (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s README file . Support for other matrix element generators is planned for futures releases, however nothing prevents plugging in any code returning the matrix element provided it is wrapped properly for MoMEMta.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"","title":"Installation"},{"location":"getting-started/#prerequisites","text":"MoMEMta depends on the following libraries and tools: LHAPDF (>=6) CMake (>=3.2) Boost (>=1.54) ROOT (>=5.34.09) A C++11-capable compiler Note MoMEMta has only been tested on GNU/Linux.","title":"Prerequisites"},{"location":"getting-started/#compilation","text":"Retrieve the code on our github repository . Unpack the archive and / or go to the MoMEMta directory. Next, execute the following (unless one of the build options described below apply to your case): mkdir build cd build cmake .. make -j 4 Finally, make MoMEMta (public headers and library) available using: make install You can now use MoMEMta with your own code.","title":"Compilation"},{"location":"getting-started/#build-options","text":"The following options are available when configuring the build (when running cmake .. ): -DCMAKE_INSTALL_PREFIX=(path) : Install MoMEMta in a specific location when running make install (useful if you don't have admin rights) -DPROFILING=ON : Generate debugging symbols and profiling information (requires gperftools ) -DBOOST_ROOT=(path) : Use specific Boost version (path to its install directory) -DTESTS=ON : Also compile the test executables -DEXAMPLES=OFF : Do not compile the example executables -DPYTHON_BINDINGS=ON|OFF ( OFF by default). Builds python bindings for MoMEMta. Requires python and boost::python. -DDEBUG_TIMING=ON|OFF ( OFF by default). If ON , a summary of how long each module ran is printed at the end of the integration. Can be useful to see which module to optimize.","title":"Build options"},{"location":"getting-started/#usage-lua-momemta","text":"In MoMEMta, the computation of weights is configured by the user through a small script written in the Lua language. Don\u2019t be scared though: no previous knowledge of Lua is needed to use MoMEMta! Computing weights in your analysis code is then a matter of only a few lines of C++: read the Lua file, instantiate MoMEMta, and call it by passing your particle 4-vectors: #include <momemta/ConfigurationReader.h> #include <momemta/MoMEMta.h> #include <momemta/Types.h> int main ( int argc , char ** argv ) { ConfigurationReader configuration ( \"tt_fullyleptonic.lua\" ); MoMEMta weight ( configuration . freeze ()); momemta :: Particle electron { \"electron\" , LorentzVector ( 16.17 , - 13.79 , - 3.43 , 21.53 ), - 11 }; momemta :: Particle bjet1 { \"bjet1\" , LorentzVector ( - 55.79 , - 111.59 , - 122.14 , 174.66 ), 5 }; momemta :: Particle bjet2 { \"bjet2\" , LorentzVector ( - 18.90 , 10.09 , - 0.60 , 21.43 ), - 5 }; momemta :: Particle muon { \"muon\" , LorentzVector ( 71.39 , 96.01 , - 77.25 , 142.50 ), 13 }; std :: vector < std :: pair < double , double >> weights = weight . computeWeights ( { electron , muon , bjet1 , bjet2 } ); std :: cout << \"Result: \" << weights . at ( 0 ). first << \" +- \" << weights . at ( 0 ). second ; return 0 ; }","title":"Usage: Lua &amp; MoMEMta"},{"location":"getting-started/#examples","text":"We ship a few example configuration files, along with short scripts computing a single weight: find them in MoMEMta/examples . To run them, simply call them from the build directory: ./tt_fullyleptonic.exe ./tt_fullyleptonic_NWA.exe ./WW_fullyleptonic.exe A set of more comprehensive examples on how to run MoMEMta can be found in our Tutorials repository . Each of these examples includes a matrix element generated by our exporter (see below), a ROOT file containing a few events, a documented Lua configuration file and a small source code showing how to compute weights for the events in the sample.","title":"Examples"},{"location":"getting-started/#matrix-elements","text":"MoMEMta includes matrix elements for a few processes, but you might soon want to compute weights for other processes. It is possible to include matrix elements for any process by using our Matrix Element Exporter , a plugin for MadGraph5_aMC@NLO (MG5). The plugin takes a leading-order matrix element generated by MG5 and exports it in a format suitable for use in MoMEMta. More information on how to use the plugin and the resulting matrix elements is provided in the plugin\u2019s README file . Support for other matrix element generators is planned for futures releases, however nothing prevents plugging in any code returning the matrix element provided it is wrapped properly for MoMEMta.","title":"Matrix elements"},{"location":"introduction/","text":"Introduction \u00b6 The Matrix Element Method \u00b6 The Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event: P(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM} Where: \\mathcal{M}_{\\alpha} is the matrix element (usually LO) under hypothesis \\alpha . The transfer function W(\\mathbf{x}|y) is the probability density that y ends up as the measured event \\mathbf{x} in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as \\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1 while the probability that y ends up as a selected event is included in the efficiency term \\epsilon_{\\alpha}(y) . f and x_i are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x; \\text{d} \\Phi(y) is the phase-space density term; s is the hadronic centre-of-mass energy. The denominator A_{\\alpha} \\sigma_{\\alpha} , including the total cross-section of the process \\alpha and the overall acceptance A_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle ensures that P is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected. This per-event likelihood has two main analysis use-cases: Constructing the sample likelihood \\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha) and measuring a parameter using the maximum likelihood method Constructing a Neyman-Pearson discriminant P(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta) to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals However, computing an integral like ( \\ref{MEM} ) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms and smart phase-space parametrisations. MoMEMta \u00b6 MoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows. The modularity of MoMEMta consists in configuring the integrand of ( \\ref{MEM} ) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using Monte-Carlo algorithms (such as Vegas) as implemented in the Cuba library. MoMEMta ships modules convering most needs, but it is possible for the user to write additional modules to perform specific tasks. It should be noted that MoMEMta provides dedicated phase-space parametrisations especially suited for the computation of MEM integrals, greatly improving the speed of the calculations compared to a naive approach. The philosophy of these parametrisations is mostly based on results described in 1 , with a few additions. Pierre Artoisenet, Vincent Lemaitre, Fabio Maltoni and Olivier Mattelaer, \u201cAutomation of the matrix element reweighting method\u201d , JHEP 12 (2010) 068 , p. 17 \u21a9","title":"What is MoMEMta?"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#the-matrix-element-method","text":"The Matrix Element Method (MEM) is a multivariate method in which a per-event likelihood (\"weight\") is computed from first principles. This weight can be expressed, given a certain theoretical hypothesis, by the convolution of the matrix element (squared) corresponding to this hypothesis, the parton distribution functions, and the transfer functions and efficiencies describing the evolution from a parton-level configuration to the observed event: P(\\mathbf{x} | \\alpha ) = \\frac{1}{A_{\\alpha} \\sigma_{\\alpha}} \\int \\text{d} \\Phi(y) \\frac{\\text{d} x_1 \\text{d} x_2}{x_1 x_2 s} \\, f(x_1) f(x_2) \\, |\\mathcal{M}_{\\alpha}(y,x_1,x_2)|^2 \\, W(\\mathbf{x}|y) \\, \\epsilon_{\\alpha}(y) \\tag{1} \\label{MEM} Where: \\mathcal{M}_{\\alpha} is the matrix element (usually LO) under hypothesis \\alpha . The transfer function W(\\mathbf{x}|y) is the probability density that y ends up as the measured event \\mathbf{x} in the detector. It describes parton shower, hadronization, and detector and reconstruction effects. It is normalised as \\int \\text{d} \\mathbf{x} \\, W(\\mathbf{x}|y) = 1 while the probability that y ends up as a selected event is included in the efficiency term \\epsilon_{\\alpha}(y) . f and x_i are the Parton Distribution Functions (PDFs) and Bj\u00f6rken-x; \\text{d} \\Phi(y) is the phase-space density term; s is the hadronic centre-of-mass energy. The denominator A_{\\alpha} \\sigma_{\\alpha} , including the total cross-section of the process \\alpha and the overall acceptance A_{\\alpha}=\\langle \\epsilon_{\\alpha}(y)\\rangle ensures that P is correctly normalised as a likelihood. In some use cases, this normalisation factor can be neglected. This per-event likelihood has two main analysis use-cases: Constructing the sample likelihood \\mathcal{L}=\\prod_{i \\in \\text{data}} P(\\mathbf{x}_i|\\alpha) and measuring a parameter using the maximum likelihood method Constructing a Neyman-Pearson discriminant P(\\mathbf{x}|\\alpha)/P(\\mathbf{x}|\\beta) to discriminate a process (signal) against others (backgrounds), useful either for conducting discrete hypothesis testing or for searches for rare processes or New Physics signals However, computing an integral like ( \\ref{MEM} ) is a difficult numerical problem, due to the presence of sharp peaks in the integrand (propagators in the matrix element, transfer functions on angles and energies). Solving it in a reasonable amout of time requires the use of both adaptive Monte-Carlo integration algorithms and smart phase-space parametrisations.","title":"The Matrix Element Method"},{"location":"introduction/#momemta","text":"MoMEMta is a modular C++ framework designed with the aim to allow a quick and efficient computation of weights under a large number of theoretical hypotheses, while remaining easily configurable by the user, enabling easy interfacing with existing analysis workflows. The modularity of MoMEMta consists in configuring the integrand of ( \\ref{MEM} ) by linking modules together. A module is responsible for a small part of the computation: transfer functions, phase-space parametrisation, matrix element, \u2026, each module\u2019s output being fed to other modules as input. This configuration is realised by the user through a file written in the Lua scripting language. The integration is then carried out by MoMEMta using Monte-Carlo algorithms (such as Vegas) as implemented in the Cuba library. MoMEMta ships modules convering most needs, but it is possible for the user to write additional modules to perform specific tasks. It should be noted that MoMEMta provides dedicated phase-space parametrisations especially suited for the computation of MEM integrals, greatly improving the speed of the calculations compared to a naive approach. The philosophy of these parametrisations is mostly based on results described in 1 , with a few additions. Pierre Artoisenet, Vincent Lemaitre, Fabio Maltoni and Olivier Mattelaer, \u201cAutomation of the matrix element reweighting method\u201d , JHEP 12 (2010) 068 , p. 17 \u21a9","title":"MoMEMta"},{"location":"in-depth/calling-momemta/","text":"In MoMEMta, the integration is defined by linking modules together in a Lua script. MoMEMta is shipped with a set of modules covering the most common needs and whose parameters, inputs and outputs are documented here . For more information on how to write the configuration file, see here . Note A module is just a C++ class deriving from the Module virtual class. You can learn more on how to create your own module and make it available for the calculation here Once the configuration file is defined, it can be loaded by MoMEMta\u2019s configuration reader: ConfigurationReader my_reader ( \"relative_path_to_lua_file.lua\" ); At this point, the user might wish to modify some parameters defined in the file from the code itself (see also here ): my_reader . getGlobalParameters (). set ( \"top_mass\" , 173. ); Then, MoMEMta can be instantiated using a \"frozen\" configuration set: Configuration my_config = my_reader . freeze (); MoMEMta weight ( my_config ); Note MoMEMta is instantiated using a Configuration object, describing a frozen configuration: parameters cannot be modified at this stage, the execution flow of the computation is fully fixed. Parameters can however be changed in the ConfigurationReader, and a new MoMEMta instance must then be constructed by calling ConfigurationReader::freeze() again. The weight can finally be computed by calling the computeWeights() method of the MoMEMta object, passing the observed particles as arguments: ROOT :: Math :: LorentzVector < ROOT :: Math :: PxPyPzE4D < double >> p1 , p2 , met ; momemta :: Particle part1 { \"part1\" , p1 , 0 }; momemta :: Particle part2 { \"part2\" , p2 , 0 }; std :: vector < std :: pair < double , double >> weights = weight . computeWeights ({ part1 , part2 }, met ); Note The MET is an optional argument (defaults to a null vector) The momemta::Particle type consists of three parts: a name (string) allowing to identify the particle in the configuration file, a 4-vector object, and a type (int). The type is not used by MoMEMta at the moment, but is present for future features. Tip MoMEMta provides the useful typedef LorentzVector for Lorentz Vectors in the file momemta/Types.h Warning MoMEMta checks that your inputs are physical, i.e. have non-negative energy and mass. Due e.g. to machine precision issues, it is possible your inputs have slightly negative masses without you noticing it. However, MoMEMta can produce nonsensical output or even crash in this case ( garbage in, garbage out ). It's up to the user to correct the inputs in those cases. The function computeWeights() starts the Monte-Carlo integration: the integrand function is called a large number of times, each time passing as input a phase-space point vector (where the length of the vector is the dimensionality of the integrated phase-space) with elements between 0 and 1, and returning as output the integrated function evaluated on this point. computeWeights() returns a vector of pairs (weight, uncertainty). In most cases, this vector will contain only one entry, but MoMEMta allows the possibility to define vector integrands, i.e. integrate multi-valued functions, and return a weight and uncertainty for each component. Python bindings \u00b6 Calling MoMEMta from python is also possible, provided the python bindings have been built (see the build options ). If you have not installed MoMEMta system-wide but in a user-defined directory (say MOMEMTA_DIR ), you should make sure the two following conditions are satisfied: $MOMEMTA_DIR/lib[64]/pythonX/site-packages/ (exact path depends on your system) should be in your PYTHONPATH $MOMEMTA_DIR/lib/ should be in your LD_LIBRARY_PATH Then, you might call MoMEMta from your python analysis script in this manner: import momemta # Restrict logging to \"error\" level momemta . set_log_level ( momemta . log_level . error ) momemta_cfg = momemta . ConfigurationReader ( \"path_to_config.lua\" ) momemta_computer = momemta . MoMEMta ( momemta_cfg . freeze ()) # px, py, pz, E p1 = [ 10 , 20 , 30 , 200 ] p2 = [ - 10 , 20 , - 30 , 200 ] ## Using ROOT 4-vectors is also possible # import ROOT # LorentzVector = ROOT.Math.LorentzVector(ROOT.Math.PxPyPzE4D(\"double\")) # p1 = LorentzVector(10, 20, 30, 200) # p2 = LorentzVector(-10, 20, -30, 200) result = momemta_computer . computeWeights ([ p1 , p2 ]) print ( \"Weight: {} +- {}\" . format ( result [ 0 ][ 0 ], result [ 0 ][ 1 ])) More information about the Python bindings can be found in the technical documentation .","title":"Calling MoMEMta"},{"location":"in-depth/calling-momemta/#python-bindings","text":"Calling MoMEMta from python is also possible, provided the python bindings have been built (see the build options ). If you have not installed MoMEMta system-wide but in a user-defined directory (say MOMEMTA_DIR ), you should make sure the two following conditions are satisfied: $MOMEMTA_DIR/lib[64]/pythonX/site-packages/ (exact path depends on your system) should be in your PYTHONPATH $MOMEMTA_DIR/lib/ should be in your LD_LIBRARY_PATH Then, you might call MoMEMta from your python analysis script in this manner: import momemta # Restrict logging to \"error\" level momemta . set_log_level ( momemta . log_level . error ) momemta_cfg = momemta . ConfigurationReader ( \"path_to_config.lua\" ) momemta_computer = momemta . MoMEMta ( momemta_cfg . freeze ()) # px, py, pz, E p1 = [ 10 , 20 , 30 , 200 ] p2 = [ - 10 , 20 , - 30 , 200 ] ## Using ROOT 4-vectors is also possible # import ROOT # LorentzVector = ROOT.Math.LorentzVector(ROOT.Math.PxPyPzE4D(\"double\")) # p1 = LorentzVector(10, 20, 30, 200) # p2 = LorentzVector(-10, 20, -30, 200) result = momemta_computer . computeWeights ([ p1 , p2 ]) print ( \"Weight: {} +- {}\" . format ( result [ 0 ][ 0 ], result [ 0 ][ 1 ])) More information about the Python bindings can be found in the technical documentation .","title":"Python bindings"},{"location":"in-depth/configuration-file/","text":"The configuration file \u00b6 Configuring modules \u00b6 Different types of modules are available on MoMEMta, each designed to perform a specific task. Declaring an instance of a module named karl of type Gaussian in Lua is simple: Gaussian . karl = {} Each module can be configured by setting its parameters and its inputs: Gaussian . karl = {} Gaussian . friedrich = { -- Some fixed parameters age = 25 , size = 1.75 , place = \"Gottingen\" , dead = true , -- Define inputs using other modules\u2019 outputs input = \"karl::output\" } A parameter is strongly typed and can be an integer (eg.: 2 ), a floating point number, (eg.: 172.5 , 13000. - note the decimal point must be present), a boolean ( true or false ) or a string (eg.: hello ). Parameters might have default values and be optional, or be mandatory. An input is set through a so-called \" input tag \" of the form other_module::its_output[/i] , where other_module is the name of another module responsible for producing the quantity its_output , and /i has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input. Some modules expect vectors of input tags, where the order of the entries may or may not matter. Vectors in Lua are easily declared: -- Take first and third entry of vector output `output` of module `that_module` inputs = { \"that_module::output/1\" , \"that_module::output/3\" } Accessing entries of previously defined vectors is also possible: temp_vector = { \"first\" , \"second\" , \"third\" } -- Use only { \"first\", \"third\" }: my_inputs = { temp_vector [ 1 ], temp_vector [ 3 ] } Warning The indexing of Lua vectors or input tags starts at 1, not 0 . The use of some modules requires adding a dimension to the volume that is being integrated over. In other words, those modules need a component of the phase-space points to be specified as input. This is done using the function add_dimension() , which returns an input tag linking to a component of the phase-space point, and notifies MoMEMta to add an integration dimension. The order in which the modules are declared in the script does not matter: MoMEMta automatically executes the modules in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed. A full list of modules available out-of-the-box, along with documentation about the modules' inputs, outputs and parameters, is available at MoMEMta's technical documentation . Declaring input particles \u00b6 Input particles are declared in the configuration file as: local l_part1 = declare_input ( \"part1\" ) -- Give that input a name: \"part1\" In C++, that input's 4-vector can then be passed through the computeWeights() function (see Calling MoMEMta ) by defining a momemta::Particle object whose name attribute is the same as the one used in the configuration, e.g. momemta::Particle m_part1 { \"part1\", p1, 0 } . The Lua object l_part1 , via the reco_p4 attribute, contains the input tag needed to access the particle's 4-vector. For instance, defining a transfer function on the energy of part1 can be done as: GaussianTransferFunctionOnEnergy . tf_part1 = { ps_point = add_dimension (), -- A transfer function integrates over a variable (the particle's energy), so we need a new dimension in the integrated volume reco_particle = l_part1 . reco_p4 , -- Pass the input tag corresponding to the experimentally reconstructed 4-vector of the particle, given to 'computeWeights()' sigma = 0.10 , -- Take 10% resolution on the energy sigma_range = 5 -- Integrate from -5*sigma*E to +5*sigma*E } Since the transfer function integrates over the particle's energy, it generates new values for its energy. This defines a new, 'parton'-level 4-vector for part1 , which can now be passed e.g. to a matrix element. In this example, the parton-level 4-vector can be accessed directly through the tf_part1::output input tag. It is also possible to register it with the l_part1 object: l_part1 . set_gen_p4 ( \"tf_part1::output\" ) When declaring further modules, instead of using tf_part1::output , it is now possible to use l_part1.gen_p4 to access the parton-level 4-vector, i.e. these are equivalent: P4Printer . printer1 = { input = \"tf_part1::output\" } P4Printer . printer2 = { input = l_part1 . gen_p4 } Note If the function set_gen_p4() is not called, one has by default l_part1.gen_p4 = l_part1.reco_p4 . For instance, if you don't use transfer functions there is no distinction needed between 'parton'- and 'reco'-level quantities. The missing transverse energy 4-vector (passed optionally to computeWeights() ) can be accessed directly through the met::p4 input tag. Declaring the integrand \u00b6 When the integration is fully configured, i.e. the final module computing the integrand value is defined, the integrand has to be registered with MoMEMta to be able to compute the integral. For instance, if the module called final_module with output output defines the integrand, one has to call: integrand ( \"final_module::output\" ) It is possible in MoMEMta to integrate multi-valued functions (caution: is only efficient if the components of the function are not too different). For two components, the integrand would then be declared as: integrand ( \"final_module_1::output\" , \"final_module_2::output\" ) In this case, computeWeights() would return a vector with two entries, embedding the value of the integral and the corresponding uncertainty for each of the two components.","title":"Configuration file"},{"location":"in-depth/configuration-file/#the-configuration-file","text":"","title":"The configuration file"},{"location":"in-depth/configuration-file/#configuring-modules","text":"Different types of modules are available on MoMEMta, each designed to perform a specific task. Declaring an instance of a module named karl of type Gaussian in Lua is simple: Gaussian . karl = {} Each module can be configured by setting its parameters and its inputs: Gaussian . karl = {} Gaussian . friedrich = { -- Some fixed parameters age = 25 , size = 1.75 , place = \"Gottingen\" , dead = true , -- Define inputs using other modules\u2019 outputs input = \"karl::output\" } A parameter is strongly typed and can be an integer (eg.: 2 ), a floating point number, (eg.: 172.5 , 13000. - note the decimal point must be present), a boolean ( true or false ) or a string (eg.: hello ). Parameters might have default values and be optional, or be mandatory. An input is set through a so-called \" input tag \" of the form other_module::its_output[/i] , where other_module is the name of another module responsible for producing the quantity its_output , and /i has to be used when the produced quantity in question is a vector and only a specific entry of that vector is needed as input. Some modules expect vectors of input tags, where the order of the entries may or may not matter. Vectors in Lua are easily declared: -- Take first and third entry of vector output `output` of module `that_module` inputs = { \"that_module::output/1\" , \"that_module::output/3\" } Accessing entries of previously defined vectors is also possible: temp_vector = { \"first\" , \"second\" , \"third\" } -- Use only { \"first\", \"third\" }: my_inputs = { temp_vector [ 1 ], temp_vector [ 3 ] } Warning The indexing of Lua vectors or input tags starts at 1, not 0 . The use of some modules requires adding a dimension to the volume that is being integrated over. In other words, those modules need a component of the phase-space points to be specified as input. This is done using the function add_dimension() , which returns an input tag linking to a component of the phase-space point, and notifies MoMEMta to add an integration dimension. The order in which the modules are declared in the script does not matter: MoMEMta automatically executes the modules in an order such that inputs are always well-defined (obviously, circular dependencies are forbidden). By default, modules whose outputs are not used by any other module, and modules whose inputs are not produced by any other modules are not executed. A full list of modules available out-of-the-box, along with documentation about the modules' inputs, outputs and parameters, is available at MoMEMta's technical documentation .","title":"Configuring modules"},{"location":"in-depth/configuration-file/#declaring-input-particles","text":"Input particles are declared in the configuration file as: local l_part1 = declare_input ( \"part1\" ) -- Give that input a name: \"part1\" In C++, that input's 4-vector can then be passed through the computeWeights() function (see Calling MoMEMta ) by defining a momemta::Particle object whose name attribute is the same as the one used in the configuration, e.g. momemta::Particle m_part1 { \"part1\", p1, 0 } . The Lua object l_part1 , via the reco_p4 attribute, contains the input tag needed to access the particle's 4-vector. For instance, defining a transfer function on the energy of part1 can be done as: GaussianTransferFunctionOnEnergy . tf_part1 = { ps_point = add_dimension (), -- A transfer function integrates over a variable (the particle's energy), so we need a new dimension in the integrated volume reco_particle = l_part1 . reco_p4 , -- Pass the input tag corresponding to the experimentally reconstructed 4-vector of the particle, given to 'computeWeights()' sigma = 0.10 , -- Take 10% resolution on the energy sigma_range = 5 -- Integrate from -5*sigma*E to +5*sigma*E } Since the transfer function integrates over the particle's energy, it generates new values for its energy. This defines a new, 'parton'-level 4-vector for part1 , which can now be passed e.g. to a matrix element. In this example, the parton-level 4-vector can be accessed directly through the tf_part1::output input tag. It is also possible to register it with the l_part1 object: l_part1 . set_gen_p4 ( \"tf_part1::output\" ) When declaring further modules, instead of using tf_part1::output , it is now possible to use l_part1.gen_p4 to access the parton-level 4-vector, i.e. these are equivalent: P4Printer . printer1 = { input = \"tf_part1::output\" } P4Printer . printer2 = { input = l_part1 . gen_p4 } Note If the function set_gen_p4() is not called, one has by default l_part1.gen_p4 = l_part1.reco_p4 . For instance, if you don't use transfer functions there is no distinction needed between 'parton'- and 'reco'-level quantities. The missing transverse energy 4-vector (passed optionally to computeWeights() ) can be accessed directly through the met::p4 input tag.","title":"Declaring input particles"},{"location":"in-depth/configuration-file/#declaring-the-integrand","text":"When the integration is fully configured, i.e. the final module computing the integrand value is defined, the integrand has to be registered with MoMEMta to be able to compute the integral. For instance, if the module called final_module with output output defines the integrand, one has to call: integrand ( \"final_module::output\" ) It is possible in MoMEMta to integrate multi-valued functions (caution: is only efficient if the components of the function are not too different). For two components, the integrand would then be declared as: integrand ( \"final_module_1::output\" , \"final_module_2::output\" ) In this case, computeWeights() would return a vector with two entries, embedding the value of the integral and the corresponding uncertainty for each of the two components.","title":"Declaring the integrand"},{"location":"in-depth/new-module/","text":"Adding a new module \u00b6 You can easily extend MoMEMta by adding new modules to perform operations not supported by the base modules. Defining the module's interface \u00b6 You declare a new module in MoMEMta by subclassing the Module class , and then registering the new module into the MoMEMta system. Let's suppose you want to declare a new module printing Hello world! at each step of the integration. You first need to include the right header: #include <momemta/Module.h> and then to subclass the Module class: class HelloWorldModule : public Module { }; If you want your new module to be useful, you'll want to override some specific functions, starting by the constructor and the work function: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; return Status :: OK ; } }; The work function is called by MoMEMta each time the integrand needs to be evaluated (thousand times per integration). With this code, our module would only output the string Hello world! and not produce anything useful, but it's fine, that's what we wanted! The only remaining thing is to register the new module into the system. Registering the module \u00b6 Before being available to MoMEMta, a module must be registered into the system. This is done using the REGISTER_MODULE macro. After the declaration of your module, simply add: REGISTER_MODULE ( HelloWorldModule ) . Sticky (); Because your module does not produce any output, MoMEMta will automatically remove it from the computation graph, since it does not contribute in any way to the final integrand value. You can prevent this behaviour by registering your module as sticky : a sticky module is not removed from the computation graph if it's found to not contribute. Loading the module \u00b6 So, you have successfully defined a new module and registered it with the system. In order to use it during the computation of the weight, you first have to load the shared library where your module is. Let's suppose your module is contained into libhelloworldmodule.so . In the lua configuration file, you need to first instruct MoMEMta to load this library to gain access to the new module: load_modules ( 'libhelloworldmodule.so' ) You can now use your new module as you would do for a built-in module: HelloWorldModule . hello = {} Using advanced features into your module \u00b6 The module we built before is nice, but not very useful. Ideally, our module wants to gather some input data, transform them and output new data that in turn can be used by other modules. So we need two features: a way to get inputs and a way to produce outputs . Inputs and outputs \u00b6 A module retrieves its inputs from the memory pool. The only moment the pool is accessible is during the construction of the module (see the first argument of the constructor). The Pool class has a get method you must use to obtain a pointer to the input. The get method accepts only a single argument, the InputTag of the input to grab. Warning Inputs can only be accessed inside the work method. Trying to access to an input in another method will result in an undefined behaviour. Let's edit our Hello, world! module to retrieve an input: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { input = pool -> get < double > ( InputTag ( \"module\" , \"output\" )); output = produce < double > ( \"my_output\" ); } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; std :: cout << \"Our input is: \" << * input << std :: endl ; * output = * input * 2 ; return Status :: OK ; } private : Value < double > input ; std :: shared_ptr < double > output ; }; First addition registers an output named my_output for this module, of type double . The second addition sets the value of the output to be twice the input value. Parameters \u00b6 In the above example, we hardcoded the InputTag used to retrieve the input. This is not a good practice, because you can't know when writing your module how the user will want to use your module and which output he wants to connect to your module. To overcome this, you can use the parameters (second argument of the constructor) to get data specified by the user inside the configuration file. In our example here, we can request the user to tell, inside the configuration, how he wants to connect our module by letting him specify the InputTag to use. Parameters are stored into a ParameterSet , which is simply a dictionary of heterogeneous types. You can access values using the get function, specifying the name of the parameter you want. Note Only a subset of types are supported by ParameterSet . You can only store and retrieve int64_t (integers), double (floating point numbers), bool , std::string , InputTag , ParameterSet , as well as std::vector of any of the previous types. We will modify our module to remove the hardcoded InputTag and require the user to pass it as a parameter: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { InputTag inputTag = parameters . get < InputTag > ( \"which_input\" ); input = pool -> get < double > ( inputTag ); output = produce < double > ( \"my_output\" ); } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; std :: cout << \"Our input is: \" << * input << std :: endl ; * output = * input * 2 ; return Status :: OK ; } private : Value < double > input ; std :: shared_ptr < double > output ; }; You can now see it's a two-step process to retrieve an input: We retrieve the parameter which_input of type InputTag , specified by the user inside the configuration file. We use this InputTag to retrieve our input. On the configuration side, the user must now specify a value for the which_input parameter: HelloWorldModule . hello = { which_input = \"module::output\" } Tip You can provide a default value when retrieving an argument. This value will be returned if the parameter is not found in the set. Tip You can use the exists method of ParameterSet to check if a given parameter exists. Module registration \u00b6 When using inputs, outputs or parameters in your modules, extra steps are needed during the registration to inform the system what are your module expectations. REGISTER_MODULE ( HelloWorldModule ) . Input ( \"which_input\" ) . Output ( \"output\" ); The above declaration informs the system that your module has one input ( which_input ) and one output ( output ). MoMEMta now expects the user to specify a value for which_input when writing the configuration file, and, more specifically, this value must be an InputTag . Attributes \u00b6 Attributes are any parameters which are not inputs. They are used to pass parameters to the module, like for example the current center of mass energy, or the mass of a particle. You define an attribute when you register the module, by specifying its name and type using the Attr or OptionalAttr methods, which expect a spec of the form: <name>: <type-expr> = <default> where <name> begins with a letter and can be composed of alphanumeric characters and underscores, and <type-expr> is a type expression of the form described below . An optional <default> value can also be specified. If it's the case, the attribute is automatically marked as optional. Let's imagine our module needs to know what's the mass of the top quark to work. We need to add a new attribute of type double : REGISTER_MODULE ( HelloWorldModule ) . Attr ( \"mass: double\" ) . Input ( \"which_input\" ) . Output ( \"output\" ); Supported types \u00b6 The following types are supported when registering a new attribute: int : signed 64-bits integer double : 64-bits floating point number string : sequence of characters bool : true or false pset : a ParameterSet list(<type>) : a list of any of the types above. Warning An InputTag attribute is an input , not an attribute. As a consequence, InputTag is not a valid type for an attribute. Danger No check is currently performed to ensure only valid types are passed as attributes in the configuration file. Full support is planned for future release. Inputs and outputs \u00b6 Inputs and outputs are untyped. To register inputs, you can use the Input method. For an output, use the Output method. These methods expect a spec of the form: [<attr>/]*<name> <name> begins with a letter and can be composed of alphanumeric characters and underscores. In the case of inputs only, you can also describe where the InputTag must be fetched using <attr> . <attr> must refer to an existing attribute (defined with the Attr method) of type pset . More than one level of nesting is possible. Here's an example illustrating this feature: REGISTER_MODULE ( HelloWorldModule ) . Attr ( \"mass: double\" ) . Attr ( \"data: pset\" ) . Input ( \"first_input\" ) . Input ( \"data/second_input\" ) . Output ( \"output\" ); This imaginary module needs two inputs: first_input will be fetched from the main parameters, while second_input will be fetched from the data attribute. You can configure such module the following way: HelloWorldModule . hello = { mass = 173.0 , data = { second_input = \"module::second_output\" }, first_input = \"module::first_output\" } More \u00b6 The sources of the built-in modules are a good source of documentation too. Those can be found on our github repository","title":"Adding a new module"},{"location":"in-depth/new-module/#adding-a-new-module","text":"You can easily extend MoMEMta by adding new modules to perform operations not supported by the base modules.","title":"Adding a new module"},{"location":"in-depth/new-module/#defining-the-modules-interface","text":"You declare a new module in MoMEMta by subclassing the Module class , and then registering the new module into the MoMEMta system. Let's suppose you want to declare a new module printing Hello world! at each step of the integration. You first need to include the right header: #include <momemta/Module.h> and then to subclass the Module class: class HelloWorldModule : public Module { }; If you want your new module to be useful, you'll want to override some specific functions, starting by the constructor and the work function: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; return Status :: OK ; } }; The work function is called by MoMEMta each time the integrand needs to be evaluated (thousand times per integration). With this code, our module would only output the string Hello world! and not produce anything useful, but it's fine, that's what we wanted! The only remaining thing is to register the new module into the system.","title":"Defining the module's interface"},{"location":"in-depth/new-module/#registering-the-module","text":"Before being available to MoMEMta, a module must be registered into the system. This is done using the REGISTER_MODULE macro. After the declaration of your module, simply add: REGISTER_MODULE ( HelloWorldModule ) . Sticky (); Because your module does not produce any output, MoMEMta will automatically remove it from the computation graph, since it does not contribute in any way to the final integrand value. You can prevent this behaviour by registering your module as sticky : a sticky module is not removed from the computation graph if it's found to not contribute.","title":"Registering the module"},{"location":"in-depth/new-module/#loading-the-module","text":"So, you have successfully defined a new module and registered it with the system. In order to use it during the computation of the weight, you first have to load the shared library where your module is. Let's suppose your module is contained into libhelloworldmodule.so . In the lua configuration file, you need to first instruct MoMEMta to load this library to gain access to the new module: load_modules ( 'libhelloworldmodule.so' ) You can now use your new module as you would do for a built-in module: HelloWorldModule . hello = {}","title":"Loading the module"},{"location":"in-depth/new-module/#using-advanced-features-into-your-module","text":"The module we built before is nice, but not very useful. Ideally, our module wants to gather some input data, transform them and output new data that in turn can be used by other modules. So we need two features: a way to get inputs and a way to produce outputs .","title":"Using advanced features into your module"},{"location":"in-depth/new-module/#inputs-and-outputs","text":"A module retrieves its inputs from the memory pool. The only moment the pool is accessible is during the construction of the module (see the first argument of the constructor). The Pool class has a get method you must use to obtain a pointer to the input. The get method accepts only a single argument, the InputTag of the input to grab. Warning Inputs can only be accessed inside the work method. Trying to access to an input in another method will result in an undefined behaviour. Let's edit our Hello, world! module to retrieve an input: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { input = pool -> get < double > ( InputTag ( \"module\" , \"output\" )); output = produce < double > ( \"my_output\" ); } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; std :: cout << \"Our input is: \" << * input << std :: endl ; * output = * input * 2 ; return Status :: OK ; } private : Value < double > input ; std :: shared_ptr < double > output ; }; First addition registers an output named my_output for this module, of type double . The second addition sets the value of the output to be twice the input value.","title":"Inputs and outputs"},{"location":"in-depth/new-module/#parameters","text":"In the above example, we hardcoded the InputTag used to retrieve the input. This is not a good practice, because you can't know when writing your module how the user will want to use your module and which output he wants to connect to your module. To overcome this, you can use the parameters (second argument of the constructor) to get data specified by the user inside the configuration file. In our example here, we can request the user to tell, inside the configuration, how he wants to connect our module by letting him specify the InputTag to use. Parameters are stored into a ParameterSet , which is simply a dictionary of heterogeneous types. You can access values using the get function, specifying the name of the parameter you want. Note Only a subset of types are supported by ParameterSet . You can only store and retrieve int64_t (integers), double (floating point numbers), bool , std::string , InputTag , ParameterSet , as well as std::vector of any of the previous types. We will modify our module to remove the hardcoded InputTag and require the user to pass it as a parameter: class HelloWorldModule : public Module { public : HelloWorldModule ( PoolPtr pool , const ParameterSet & parameters ) : Module ( pool , parameters . getModuleName ()) { InputTag inputTag = parameters . get < InputTag > ( \"which_input\" ); input = pool -> get < double > ( inputTag ); output = produce < double > ( \"my_output\" ); } virtual Status work () override { std :: cout << \"Hello world!\" << std :: endl ; std :: cout << \"Our input is: \" << * input << std :: endl ; * output = * input * 2 ; return Status :: OK ; } private : Value < double > input ; std :: shared_ptr < double > output ; }; You can now see it's a two-step process to retrieve an input: We retrieve the parameter which_input of type InputTag , specified by the user inside the configuration file. We use this InputTag to retrieve our input. On the configuration side, the user must now specify a value for the which_input parameter: HelloWorldModule . hello = { which_input = \"module::output\" } Tip You can provide a default value when retrieving an argument. This value will be returned if the parameter is not found in the set. Tip You can use the exists method of ParameterSet to check if a given parameter exists.","title":"Parameters"},{"location":"in-depth/new-module/#module-registration","text":"When using inputs, outputs or parameters in your modules, extra steps are needed during the registration to inform the system what are your module expectations. REGISTER_MODULE ( HelloWorldModule ) . Input ( \"which_input\" ) . Output ( \"output\" ); The above declaration informs the system that your module has one input ( which_input ) and one output ( output ). MoMEMta now expects the user to specify a value for which_input when writing the configuration file, and, more specifically, this value must be an InputTag .","title":"Module registration"},{"location":"in-depth/new-module/#attributes","text":"Attributes are any parameters which are not inputs. They are used to pass parameters to the module, like for example the current center of mass energy, or the mass of a particle. You define an attribute when you register the module, by specifying its name and type using the Attr or OptionalAttr methods, which expect a spec of the form: <name>: <type-expr> = <default> where <name> begins with a letter and can be composed of alphanumeric characters and underscores, and <type-expr> is a type expression of the form described below . An optional <default> value can also be specified. If it's the case, the attribute is automatically marked as optional. Let's imagine our module needs to know what's the mass of the top quark to work. We need to add a new attribute of type double : REGISTER_MODULE ( HelloWorldModule ) . Attr ( \"mass: double\" ) . Input ( \"which_input\" ) . Output ( \"output\" );","title":"Attributes"},{"location":"in-depth/new-module/#supported-types","text":"The following types are supported when registering a new attribute: int : signed 64-bits integer double : 64-bits floating point number string : sequence of characters bool : true or false pset : a ParameterSet list(<type>) : a list of any of the types above. Warning An InputTag attribute is an input , not an attribute. As a consequence, InputTag is not a valid type for an attribute. Danger No check is currently performed to ensure only valid types are passed as attributes in the configuration file. Full support is planned for future release.","title":"Supported types"},{"location":"in-depth/new-module/#inputs-and-outputs_1","text":"Inputs and outputs are untyped. To register inputs, you can use the Input method. For an output, use the Output method. These methods expect a spec of the form: [<attr>/]*<name> <name> begins with a letter and can be composed of alphanumeric characters and underscores. In the case of inputs only, you can also describe where the InputTag must be fetched using <attr> . <attr> must refer to an existing attribute (defined with the Attr method) of type pset . More than one level of nesting is possible. Here's an example illustrating this feature: REGISTER_MODULE ( HelloWorldModule ) . Attr ( \"mass: double\" ) . Attr ( \"data: pset\" ) . Input ( \"first_input\" ) . Input ( \"data/second_input\" ) . Output ( \"output\" ); This imaginary module needs two inputs: first_input will be fetched from the main parameters, while second_input will be fetched from the data attribute. You can configure such module the following way: HelloWorldModule . hello = { mass = 173.0 , data = { second_input = \"module::second_output\" }, first_input = \"module::first_output\" }","title":"Inputs and outputs"},{"location":"in-depth/new-module/#more","text":"The sources of the built-in modules are a good source of documentation too. Those can be found on our github repository","title":"More"},{"location":"in-depth/parameters/","text":"Defining parameters \u00b6 In MoMEMta, once the ConfigurationReader has been \"frozen\" to give a Configuration object, it is not possible anymore to modify anything in the integration. However, some parameters can be modified in the ConfigurationReader from the C++ code (allowing e.g. to carry out mass scans easily). In order to do that, the parameters have to be put in the special parameters table in Lua: parameters = { my_mass = 173. , my_width = 2.5 } These parameters can then be linked with the modules' parameters using the parameter() Lua function: BreitWignerGenerator . m_prop = { ps_point = add_dimension (), mass = parameter ( 'my_mass' ), -- Access the value through the \"parameter\" function, allowing it to be modified from the C++ code width = parameters . my_width -- Access the value as a regular Lua table. It will NOT be possible to modify it later on } Danger Accessing the parameter entries directly, as parameters.my_width or parameters['my_width'] , makes it impossible to modify them from the C++ code. The latter is only possible when using the parameter() function. List of existing parameters \u00b6 In addition to parameters accessible to modules, some parameters are read directly by MoMEMta and can influence its behavior. You can find the full list below: Parameter Allowed values Default value Description export_graph_as Any file name None Set this parameter to any value to export the computation graph built by MoMEMta. This is useful to visually see how your weight is computed. Configuring the integration algorithm \u00b6 The integration algorithm can be configured from within Lua using the cuba table, for instance: cuba = { algorithm = \"divonne\" , -- default is \"vegas\" relative_accuracy = 0.01 } Four different integration algorithms are available, and each has several parameters than can be tweaked to adjust their behaviour, tweak the precision of the calculations, ... The integration parameters can be changed from the C++ in a manner similar to the \"global\" parameters (see previous section ), using the method ConfigurationReader::getCubaConfiguration() . The available algorithms and corresponding options are briefly listed here; for a full description, please consult the documentation of the numerical integration library used in MoMEMta: Cuba 1 . Bear in mind the default values for these parameters are not guaranteed to be optimal for your particular case! It's your job to ensure the algorithm is tweaked to work well for the events and the functions you'll be integrating. Integration algorithm: Parameter Allowed values Default value algorithm vegas , suave , divonne , cuhre vegas Common arguments: Parameter Allowed values Default value relative_accuracy floats 0.005 absolute_accuracy floats 0. seed integers 0 min_eval integers 0 max_eval integers 500000 grid_file paths verbosity integers 0 subregion booleans false retainStateFile booleans false levels integers 0 ncores integers 0 pcores integers 1000000 Vegas-specific arguments: Parameter Allowed values Default value takeOnlyGridFromFile booleans true n_start integers 25000 n_increase integers 0 batch_size integers min(n_start, 50000) grid_number integers 0 smoothing booleans true Suave-specific arguments: Parameter Allowed values Default value n_new integers 1000 n_min integers 2 flatness floats 0.25 Divonne-specific arguments: Parameter Allowed values Default value key1 integers 47 key2 integers 1 key3 integers 1 maxpass integers 5 border floats 0. maxchisq floats 10. mindeviation floats 0.25 Cuhre-specific arguments: Parameter Allowed values Default value key integers 0 Passing arguments to the configuration \u00b6 Once the ConfigurationReader has parsed the Lua configuration file, it is not possible anymore to change the resulting computation flow (the only changes possible are the above parameters). It is however possible to pass arguments from C++ to the Lua script when it is read by the ConfigurationReader , to influence its execution. Defining the arguments in C++: ParameterSet lua_parameters ; lua_parameters . set ( \"text1\" , \"hello, world!\" ); lua_parameters . set ( \"text2\" , \"always look on the bright side of life!\" ); lua_parameters . set ( \"question\" , true ); ConfigurationReader configuration ( \"example.lua\" , lua_parameters ); Makes them available in Lua, i.e.: if question then print ( test1 ) else print ( test2 ) end Would print \"hello, world!\". T. Hahn, \"Cuba - a library for multidimensional numerical integration\" \u21a9","title":"Parameters"},{"location":"in-depth/parameters/#defining-parameters","text":"In MoMEMta, once the ConfigurationReader has been \"frozen\" to give a Configuration object, it is not possible anymore to modify anything in the integration. However, some parameters can be modified in the ConfigurationReader from the C++ code (allowing e.g. to carry out mass scans easily). In order to do that, the parameters have to be put in the special parameters table in Lua: parameters = { my_mass = 173. , my_width = 2.5 } These parameters can then be linked with the modules' parameters using the parameter() Lua function: BreitWignerGenerator . m_prop = { ps_point = add_dimension (), mass = parameter ( 'my_mass' ), -- Access the value through the \"parameter\" function, allowing it to be modified from the C++ code width = parameters . my_width -- Access the value as a regular Lua table. It will NOT be possible to modify it later on } Danger Accessing the parameter entries directly, as parameters.my_width or parameters['my_width'] , makes it impossible to modify them from the C++ code. The latter is only possible when using the parameter() function.","title":"Defining parameters"},{"location":"in-depth/parameters/#list-of-existing-parameters","text":"In addition to parameters accessible to modules, some parameters are read directly by MoMEMta and can influence its behavior. You can find the full list below: Parameter Allowed values Default value Description export_graph_as Any file name None Set this parameter to any value to export the computation graph built by MoMEMta. This is useful to visually see how your weight is computed.","title":"List of existing parameters"},{"location":"in-depth/parameters/#configuring-the-integration-algorithm","text":"The integration algorithm can be configured from within Lua using the cuba table, for instance: cuba = { algorithm = \"divonne\" , -- default is \"vegas\" relative_accuracy = 0.01 } Four different integration algorithms are available, and each has several parameters than can be tweaked to adjust their behaviour, tweak the precision of the calculations, ... The integration parameters can be changed from the C++ in a manner similar to the \"global\" parameters (see previous section ), using the method ConfigurationReader::getCubaConfiguration() . The available algorithms and corresponding options are briefly listed here; for a full description, please consult the documentation of the numerical integration library used in MoMEMta: Cuba 1 . Bear in mind the default values for these parameters are not guaranteed to be optimal for your particular case! It's your job to ensure the algorithm is tweaked to work well for the events and the functions you'll be integrating. Integration algorithm: Parameter Allowed values Default value algorithm vegas , suave , divonne , cuhre vegas Common arguments: Parameter Allowed values Default value relative_accuracy floats 0.005 absolute_accuracy floats 0. seed integers 0 min_eval integers 0 max_eval integers 500000 grid_file paths verbosity integers 0 subregion booleans false retainStateFile booleans false levels integers 0 ncores integers 0 pcores integers 1000000 Vegas-specific arguments: Parameter Allowed values Default value takeOnlyGridFromFile booleans true n_start integers 25000 n_increase integers 0 batch_size integers min(n_start, 50000) grid_number integers 0 smoothing booleans true Suave-specific arguments: Parameter Allowed values Default value n_new integers 1000 n_min integers 2 flatness floats 0.25 Divonne-specific arguments: Parameter Allowed values Default value key1 integers 47 key2 integers 1 key3 integers 1 maxpass integers 5 border floats 0. maxchisq floats 10. mindeviation floats 0.25 Cuhre-specific arguments: Parameter Allowed values Default value key integers 0","title":"Configuring the integration algorithm"},{"location":"in-depth/parameters/#passing-arguments-to-the-configuration","text":"Once the ConfigurationReader has parsed the Lua configuration file, it is not possible anymore to change the resulting computation flow (the only changes possible are the above parameters). It is however possible to pass arguments from C++ to the Lua script when it is read by the ConfigurationReader , to influence its execution. Defining the arguments in C++: ParameterSet lua_parameters ; lua_parameters . set ( \"text1\" , \"hello, world!\" ); lua_parameters . set ( \"text2\" , \"always look on the bright side of life!\" ); lua_parameters . set ( \"question\" , true ); ConfigurationReader configuration ( \"example.lua\" , lua_parameters ); Makes them available in Lua, i.e.: if question then print ( test1 ) else print ( test2 ) end Would print \"hello, world!\". T. Hahn, \"Cuba - a library for multidimensional numerical integration\" \u21a9","title":"Passing arguments to the configuration"},{"location":"in-depth/validation/","text":"Validation \u00b6 The phase-space parametrisations in terms of blocks are validated using two differents methods: Computation of a cross-section : the block is used to compute the cross-section of a given process. The result is then compared to the cross-section computed using MadGraph 1 for the same process. Computation of a phase-space volume : only the phase-space density is integrated (no PDF or matrix element), and the result is compared with the analytical result for production of n massless particles at a hadronic centre-of-mass energy of \\sqrt{s} GeV: V(\\sqrt{s}, n) = \\frac{s^{n-3}}{2^{4(n-1)} \\pi^{2n-3} (n-1) (n-2)^2 ((n-2)!)^2} In both cases, MoMEMta's phase-space parametrisations are not efficient for the problem, but by increasing the number of integrand evaluations to a very large number, sufficient precision can be reached nonetheless. Block A \u00b6 Cross-section \u00b6 The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: Phase-space volume \u00b6 Volume computed: production of 3 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 6.3 \\cdot 10^{-15} MoMEMta phase-space volume: 6.299(6) \\cdot 10^{-15} Block B \u00b6 Cross-section \u00b6 The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.868(8) pb Phase-space volume \u00b6 Volume computed: production of 3 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 6.3 \\cdot 10^{-15} MoMEMta phase-space volume: 6.297(6) \\cdot 10^{-15} Block D \u00b6 The process used is pp \\rightarrow t\\bar{t} fully-leptonic MadGraph cross-section: 6.73(2) pb MoMEMta cross-section: 6.69(3) pb Phase-space volume \u00b6 Volume computed: production of 6 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume : 694 \\text{GeV}^6 MoMEMta phase-space volume: 695(4) \\text{GeV}^6 Block F \u00b6 Cross-section \u00b6 The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.864(4) pb Phase-space volume \u00b6 Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.0166(3) \\text{GeV}^2 Block G \u00b6 Cross-section \u00b6 The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.864(4) pb Phase-space volume \u00b6 Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.01659(3) \\text{GeV}^2 Secondary Block C/D \u00b6 Cross-section \u00b6 The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} Main block used for computation: B MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.868(8) pb Phase-space volume \u00b6 Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Main block used for computation: A Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.01663(6) \\text{GeV}^2 J. Alwall et al., \u201cThe automated computation of tree-level and next-to-leading order differential cross sections, and their matching to parton shower simulations\u201d , JHEP 07 (2014) 079 \u21a9","title":"Validation"},{"location":"in-depth/validation/#validation","text":"The phase-space parametrisations in terms of blocks are validated using two differents methods: Computation of a cross-section : the block is used to compute the cross-section of a given process. The result is then compared to the cross-section computed using MadGraph 1 for the same process. Computation of a phase-space volume : only the phase-space density is integrated (no PDF or matrix element), and the result is compared with the analytical result for production of n massless particles at a hadronic centre-of-mass energy of \\sqrt{s} GeV: V(\\sqrt{s}, n) = \\frac{s^{n-3}}{2^{4(n-1)} \\pi^{2n-3} (n-1) (n-2)^2 ((n-2)!)^2} In both cases, MoMEMta's phase-space parametrisations are not efficient for the problem, but by increasing the number of integrand evaluations to a very large number, sufficient precision can be reached nonetheless.","title":"Validation"},{"location":"in-depth/validation/#block-a","text":"","title":"Block A"},{"location":"in-depth/validation/#cross-section","text":"The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section:","title":"Cross-section"},{"location":"in-depth/validation/#phase-space-volume","text":"Volume computed: production of 3 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 6.3 \\cdot 10^{-15} MoMEMta phase-space volume: 6.299(6) \\cdot 10^{-15}","title":"Phase-space volume"},{"location":"in-depth/validation/#block-b","text":"","title":"Block B"},{"location":"in-depth/validation/#cross-section_1","text":"The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.868(8) pb","title":"Cross-section"},{"location":"in-depth/validation/#phase-space-volume_1","text":"Volume computed: production of 3 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 6.3 \\cdot 10^{-15} MoMEMta phase-space volume: 6.297(6) \\cdot 10^{-15}","title":"Phase-space volume"},{"location":"in-depth/validation/#block-d","text":"The process used is pp \\rightarrow t\\bar{t} fully-leptonic MadGraph cross-section: 6.73(2) pb MoMEMta cross-section: 6.69(3) pb","title":"Block D"},{"location":"in-depth/validation/#phase-space-volume_2","text":"Volume computed: production of 6 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume : 694 \\text{GeV}^6 MoMEMta phase-space volume: 695(4) \\text{GeV}^6","title":"Phase-space volume"},{"location":"in-depth/validation/#block-f","text":"","title":"Block F"},{"location":"in-depth/validation/#cross-section_2","text":"The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.864(4) pb","title":"Cross-section"},{"location":"in-depth/validation/#phase-space-volume_3","text":"Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.0166(3) \\text{GeV}^2","title":"Phase-space volume"},{"location":"in-depth/validation/#block-g","text":"","title":"Block G"},{"location":"in-depth/validation/#cross-section_3","text":"The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.864(4) pb","title":"Cross-section"},{"location":"in-depth/validation/#phase-space-volume_4","text":"Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.01659(3) \\text{GeV}^2","title":"Phase-space volume"},{"location":"in-depth/validation/#secondary-block-cd","text":"","title":"Secondary Block C/D"},{"location":"in-depth/validation/#cross-section_4","text":"The process used is pp \\rightarrow W^+W^- \\rightarrow \\mu^+\\mu^-\\nu\\bar{\\nu} Main block used for computation: B MadGraph cross-section: 0.866(5) pb MoMEMta cross-section: 0.868(8) pb","title":"Cross-section"},{"location":"in-depth/validation/#phase-space-volume_5","text":"Volume computed: production of 4 massless particles at \\sqrt{s} = 1 TeV Main block used for computation: A Theoretical phase-space volume: 0.0166 \\text{GeV}^2 MoMEMta phase-space volume: 0.01663(6) \\text{GeV}^2 J. Alwall et al., \u201cThe automated computation of tree-level and next-to-leading order differential cross sections, and their matching to parton shower simulations\u201d , JHEP 07 (2014) 079 \u21a9","title":"Phase-space volume"}]}